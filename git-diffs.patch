diff --git a/MacPlus.sv b/MacPlus.sv
index 14c7450..2e6a712 100644
--- a/MacPlus.sv
+++ b/MacPlus.sv
@@ -1,849 +1,895 @@
-//============================================================================
-//  Macintosh Plus
-//
-//  Port to MiSTer
-//  Copyright (C) 2017-2019 Sorgelig
-//
-//  This program is free software; you can redistribute it and/or modify it
-//  under the terms of the GNU General Public License as published by the Free
-//  Software Foundation; either version 2 of the License, or (at your option)
-//  any later version.
-//
-//  This program is distributed in the hope that it will be useful, but WITHOUT
-//  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-//  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
-//  more details.
-//
-//  You should have received a copy of the GNU General Public License along
-//  with this program; if not, write to the Free Software Foundation, Inc.,
-//  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
-//============================================================================
-
-module emu
-(
-	//Master input clock
-	input         CLK_50M,
-
-	//Async reset from top-level module.
-	//Can be used as initial reset.
-	input         RESET,
-
-	//Must be passed to hps_io module
-	inout  [48:0] HPS_BUS,
-
-	//Base video clock. Usually equals to CLK_SYS.
-	output        CLK_VIDEO,
-
-	//Multiple resolutions are supported using different CE_PIXEL rates.
-	//Must be based on CLK_VIDEO
-	output        CE_PIXEL,
-
-	//Video aspect ratio for HDMI. Most retro systems have ratio 4:3.
-	//if VIDEO_ARX[12] or VIDEO_ARY[12] is set then [11:0] contains scaled size instead of aspect ratio.
-	output [12:0] VIDEO_ARX,
-	output [12:0] VIDEO_ARY,
-
-	output  [7:0] VGA_R,
-	output  [7:0] VGA_G,
-	output  [7:0] VGA_B,
-	output        VGA_HS,
-	output        VGA_VS,
-	output        VGA_DE,    // = ~(VBlank | HBlank)
-	output        VGA_F1,
-	output [1:0]  VGA_SL,
-	output        VGA_SCALER, // Force VGA scaler
-	output        VGA_DISABLE, // analog out is off
-
-	input  [11:0] HDMI_WIDTH,
-	input  [11:0] HDMI_HEIGHT,
-	output        HDMI_FREEZE,
-	output        HDMI_BLACKOUT,
+//============================================================================
+//  Macintosh Plus
+//
+//  Port to MiSTer
+//  Copyright (C) 2017-2019 Sorgelig
+//
+//  This program is free software; you can redistribute it and/or modify it
+//  under the terms of the GNU General Public License as published by the Free
+//  Software Foundation; either version 2 of the License, or (at your option)
+//  any later version.
+//
+//  This program is distributed in the hope that it will be useful, but WITHOUT
+//  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+//  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+//  more details.
+//
+//  You should have received a copy of the GNU General Public License along
+//  with this program; if not, write to the Free Software Foundation, Inc.,
+//  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+//============================================================================
+
+module emu
+(
+	//Master input clock
+	input         CLK_50M,
+
+	//Async reset from top-level module.
+	//Can be used as initial reset.
+	input         RESET,
+
+	//Must be passed to hps_io module
+	inout  [48:0] HPS_BUS,
+
+	//Base video clock. Usually equals to CLK_SYS.
+	output        CLK_VIDEO,
+
+	//Multiple resolutions are supported using different CE_PIXEL rates.
+	//Must be based on CLK_VIDEO
+	output        CE_PIXEL,
+
+	//Video aspect ratio for HDMI. Most retro systems have ratio 4:3.
+	//if VIDEO_ARX[12] or VIDEO_ARY[12] is set then [11:0] contains scaled size instead of aspect ratio.
+	output [12:0] VIDEO_ARX,
+	output [12:0] VIDEO_ARY,
+
+	output  [7:0] VGA_R,
+	output  [7:0] VGA_G,
+	output  [7:0] VGA_B,
+	output        VGA_HS,
+	output        VGA_VS,
+	output        VGA_DE,    // = ~(VBlank | HBlank)
+	output        VGA_F1,
+	output [1:0]  VGA_SL,
+	output        VGA_SCALER, // Force VGA scaler
+	output        VGA_DISABLE, // analog out is off
+
+	input  [11:0] HDMI_WIDTH,
+	input  [11:0] HDMI_HEIGHT,
+	output        HDMI_FREEZE,
+	output        HDMI_BLACKOUT,
 	output        HDMI_BOB_DEINT,
-
-`ifdef MISTER_FB
-	// Use framebuffer in DDRAM
-	// FB_FORMAT:
-	//    [2:0] : 011=8bpp(palette) 100=16bpp 101=24bpp 110=32bpp
-	//    [3]   : 0=16bits 565 1=16bits 1555
-	//    [4]   : 0=RGB  1=BGR (for 16/24/32 modes)
-	//
-	// FB_STRIDE either 0 (rounded to 256 bytes) or multiple of pixel size (in bytes)
-	output        FB_EN,
-	output  [4:0] FB_FORMAT,
-	output [11:0] FB_WIDTH,
-	output [11:0] FB_HEIGHT,
-	output [31:0] FB_BASE,
-	output [13:0] FB_STRIDE,
-	input         FB_VBL,
-	input         FB_LL,
-	output        FB_FORCE_BLANK,
-
-`ifdef MISTER_FB_PALETTE
-	// Palette control for 8bit modes.
-	// Ignored for other video modes.
-	output        FB_PAL_CLK,
-	output  [7:0] FB_PAL_ADDR,
-	output [23:0] FB_PAL_DOUT,
-	input  [23:0] FB_PAL_DIN,
-	output        FB_PAL_WR,
-`endif
-`endif
-
-	output        LED_USER,  // 1 - ON, 0 - OFF.
-
-	// b[1]: 0 - LED status is system status OR'd with b[0]
-	//       1 - LED status is controled solely by b[0]
-	// hint: supply 2'b00 to let the system control the LED.
-	output  [1:0] LED_POWER,
-	output  [1:0] LED_DISK,
-
-	// I/O board button press simulation (active high)
-	// b[1]: user button
-	// b[0]: osd button
-	output  [1:0] BUTTONS,
-
-	input         CLK_AUDIO, // 24.576 MHz
-	output [15:0] AUDIO_L,
-	output [15:0] AUDIO_R,
-	output        AUDIO_S,   // 1 - signed audio samples, 0 - unsigned
-	output  [1:0] AUDIO_MIX, // 0 - no mix, 1 - 25%, 2 - 50%, 3 - 100% (mono)
-
-	//ADC
-	inout   [3:0] ADC_BUS,
-
-	//SD-SPI
-	output        SD_SCK,
-	output        SD_MOSI,
-	input         SD_MISO,
-	output        SD_CS,
-	input         SD_CD,
-
-	//High latency DDR3 RAM interface
-	//Use for non-critical time purposes
-	output        DDRAM_CLK,
-	input         DDRAM_BUSY,
-	output  [7:0] DDRAM_BURSTCNT,
-	output [28:0] DDRAM_ADDR,
-	input  [63:0] DDRAM_DOUT,
-	input         DDRAM_DOUT_READY,
-	output        DDRAM_RD,
-	output [63:0] DDRAM_DIN,
-	output  [7:0] DDRAM_BE,
-	output        DDRAM_WE,
-
-	//SDRAM interface with lower latency
-	output        SDRAM_CLK,
-	output        SDRAM_CKE,
-	output [12:0] SDRAM_A,
-	output  [1:0] SDRAM_BA,
-	inout  [15:0] SDRAM_DQ,
-	output        SDRAM_DQML,
-	output        SDRAM_DQMH,
-	output        SDRAM_nCS,
-	output        SDRAM_nCAS,
-	output        SDRAM_nRAS,
-	output        SDRAM_nWE,
-
-`ifdef MISTER_DUAL_SDRAM
-	//Secondary SDRAM
-	//Set all output SDRAM_* signals to Z ASAP if SDRAM2_EN is 0
-	input         SDRAM2_EN,
-	output        SDRAM2_CLK,
-	output [12:0] SDRAM2_A,
-	output  [1:0] SDRAM2_BA,
-	inout  [15:0] SDRAM2_DQ,
-	output        SDRAM2_nCS,
-	output        SDRAM2_nCAS,
-	output        SDRAM2_nRAS,
-	output        SDRAM2_nWE,
-`endif
-
-	input         UART_CTS,
-	output        UART_RTS,
-	input         UART_RXD,
-	output        UART_TXD,
-	output        UART_DTR,
-	input         UART_DSR,
-
-	// Open-drain User port.
-	// 0 - D+/RX
-	// 1 - D-/TX
-	// 2..6 - USR2..USR6
-	// Set USER_OUT to 1 to read from USER_IN.
-	input   [6:0] USER_IN,
-	output  [6:0] USER_OUT,
-
-	input         OSD_STATUS
-);
-
-assign ADC_BUS  = 'Z;
-assign USER_OUT = '1;
-
-assign {DDRAM_CLK, DDRAM_BURSTCNT, DDRAM_ADDR, DDRAM_DIN, DDRAM_BE, DDRAM_RD, DDRAM_WE} = 0; 
-assign {SD_SCK, SD_MOSI, SD_CS} = 'Z;
-
-assign LED_USER  = dio_download || (disk_act ^ |diskMotor);
-assign LED_DISK  = 0;
-assign LED_POWER = 0;
-assign BUTTONS   = 0;
-assign VGA_SCALER= 0;
-assign VGA_DISABLE = 0;
-assign HDMI_FREEZE = 0;
-assign HDMI_BLACKOUT = 0;
-assign HDMI_BOB_DEINT = 0;
-
-wire [1:0] ar = status[8:7];
-video_freak video_freak
-(
-	.*,
-	.VGA_DE_IN(VGA_DE),
-	.VGA_DE(),
-
-	.ARX((!ar) ? 12'd256 : (ar - 1'd1)),
-	.ARY((!ar) ? 12'd171 : 12'd0),
-	.CROP_SIZE(0),
-	.CROP_OFF(0),
-	.SCALE(status[12:11])
-);
-
-`include "build_id.v" 
-localparam CONF_STR = {
-	"MACPLUS;UART115200;",
-	"-;",
-	"F1,DSK,Mount Pri Floppy;",
-	"F2,DSK,Mount Sec Floppy;",
-	"-;",
-	"SC0,IMGVHD,Mount SCSI-6;",
-	"SC1,IMGVHD,Mount SCSI-5;",
-	"-;",
-	"O78,Aspect ratio,Original,Full Screen,[ARC1],[ARC2];",
-	"OBC,Scale,Normal,V-Integer,Narrower HV-Integer,Wider HV-Integer;",
-	"-;",
-	"O9,Model,Plus,SE;",
-	"O5,Speed,8MHz,16MHz;",
-	"ODE,CPU,68000,68010,68020;",
-	"O4,Memory,1MB,4MB;",
-	"-;",
-	//"OA,Serial,Off,On;",
-	//"-;",
-	"R0,Reset & Apply CPU+Memory;",
-	"v,0;", // [optional] config version 0-99. 
-	        // If CONF_STR options are changed in incompatible way, then change version number too,
-			// so all options will get default values on first start.
-	"V,v",`BUILD_DATE
-};
-
-wire status_turbo = status[5];
-
-////////////////////   CLOCKS   ///////////////////
-
-wire clk_sys, clk_mem;
-wire pll_locked;
-
-pll pll
-(
-	.refclk(CLK_50M),
-	.outclk_0(clk_mem),
-	.outclk_1(clk_sys),
-	.locked(pll_locked)
-);
-
-reg       status_mem;
-reg [1:0] status_cpu;
-reg       status_mod;
-reg       n_reset = 0;
-always @(posedge clk_sys) begin
-	reg [15:0] rst_cnt;
-
-	if (clk8_en_p) begin
-		// various sources can reset the mac
-		if(~pll_locked || status[0] || buttons[1] || RESET || ~_cpuReset_o) begin
-			rst_cnt <= '1;
-			n_reset <= 0;
-		end
-		else if(rst_cnt) begin
-			rst_cnt    <= rst_cnt - 1'd1;
-			status_mem <= status[4];
-			status_cpu <= status[14:13];
-			status_mod <= status[9];
-		end
-		else begin
-			n_reset <= 1;
-		end
-	end
-end
-
-///////////////////////////////////////////////////
-
-localparam SCSI_DEVS = 2;
-
-// the status register is controlled by the on screen display (OSD)
-wire [31:0] status;
-wire  [1:0] buttons;
-wire [31:0] sd_lba[SCSI_DEVS];
-wire  [SCSI_DEVS-1:0] sd_rd;
-wire  [SCSI_DEVS-1:0] sd_wr;
-wire  [SCSI_DEVS-1:0] sd_ack;
-wire            [7:0] sd_buff_addr;
-wire           [15:0] sd_buff_dout;
-wire           [15:0] sd_buff_din[SCSI_DEVS];
-wire                  sd_buff_wr;
-wire  [SCSI_DEVS-1:0] img_mounted;
-wire           [63:0] img_size;
-
-wire        ioctl_write;
-reg         ioctl_wait = 0;
-
-wire [10:0] ps2_key;
-wire [24:0] ps2_mouse;
-wire        capslock;
-
-wire [24:0] ioctl_addr;
-wire [15:0] ioctl_data;
-
-wire [32:0] TIMESTAMP;
-
-hps_io #(.CONF_STR(CONF_STR), .VDNUM(SCSI_DEVS), .WIDE(1)) hps_io
-(
-	.clk_sys(clk_sys),
-	.HPS_BUS(HPS_BUS),
-
-	.buttons(buttons),
-	.status(status),
-
-	.sd_lba(sd_lba),
-	.sd_rd(sd_rd),
-	.sd_wr(sd_wr),
-	.sd_ack(sd_ack),
-
-	.sd_buff_addr(sd_buff_addr),
-	.sd_buff_dout(sd_buff_dout),
-	.sd_buff_din(sd_buff_din),
-	.sd_buff_wr(sd_buff_wr),
-	
-	.img_mounted(img_mounted),
-	.img_size(img_size),
-
-	.ioctl_download(dio_download),
-	.ioctl_index(dio_index),
-	.ioctl_wr(ioctl_write),
-	.ioctl_addr(ioctl_addr),
-	.ioctl_dout(ioctl_data),
-	.ioctl_wait(ioctl_wait),
-
-	.TIMESTAMP(TIMESTAMP),
-
-	.ps2_key(ps2_key),
-	.ps2_kbd_led_use(3'b001),
-	.ps2_kbd_led_status({2'b00, capslock}),
-
-	.ps2_mouse(ps2_mouse)
-);
-
-assign CLK_VIDEO = clk_sys;
-assign CE_PIXEL  = 1;
-
-assign VGA_R  = {8{pixelOut}};
-assign VGA_G  = {8{pixelOut}};
-assign VGA_B  = {8{pixelOut}};
-assign VGA_DE = _vblank & _hblank;
-assign VGA_VS = vsync;
-assign VGA_HS = hsync;
-assign VGA_F1 = 0;
-assign VGA_SL = 0;
-
-wire [10:0] audio;
-assign AUDIO_L = {audio[10:0], 5'b00000};
-assign AUDIO_R = {audio[10:0], 5'b00000};
-assign AUDIO_S = 1;
-assign AUDIO_MIX = 0;
-
-
-// ------------------------------ Plus Too Bus Timing ---------------------------------
-// for stability and maintainability reasons the whole timing has been simplyfied:
-//                00           01             10           11
-//    ______ _____________ _____________ _____________ _____________ ___
-//    ______X_video_cycle_X__cpu_cycle__X__IO_cycle___X__cpu_cycle__X___
-//                        ^      ^    ^                      ^    ^
-//                        |      |    |                      |    |
-//                      video    | CPU|                      | CPU|
-//                       read   write read                  write read
-
-
-
-// set the real-world inputs to sane defaults
-localparam 	  configROMSize = 1'b1;  // 128K ROM
-
-wire [1:0] configRAMSize = status_mem?2'b11:2'b10; // 1MB/4MB
-			  
-//
-// Serial Ports
-//
-wire serialOut;
-wire serialIn;
-wire serialCTS;
-wire serialRTS;
-
-/*
-assign serialIn = ~status[10] ? 0 : UART_RXD;
-assign UART_TXD = serialOut;
-assign serialCTS = UART_CTS;
-assign UART_RTS = serialRTS;
-assign UART_DTR = UART_DSR;
-*/
-
-//assign serialIn = ~status[10] ? 0 : UART_RXD;
-assign serialIn =  UART_RXD;
-assign UART_TXD = serialOut;
-//assign UART_RTS = UART_CTS;
-assign UART_RTS = serialRTS ;
-assign UART_DTR = UART_DSR;
-
-//assign {UART_RTS, UART_TXD, UART_DTR} = 0;
-/*
-	input         UART_CTS,
-	output        UART_RTS,
-	input         UART_RXD,
-	output        UART_TXD,
-	output        UART_DTR,
-	input         UART_DSR,
-*/
-
-
-// interconnects
-// CPU
-wire clk8, _cpuReset, _cpuReset_o, _cpuUDS, _cpuLDS, _cpuRW, _cpuAS;
-wire clk8_en_p, clk8_en_n;
-wire clk16_en_p, clk16_en_n;
-wire _cpuVMA, _cpuVPA, _cpuDTACK;
-wire E_rising, E_falling;
-wire [2:0] _cpuIPL;
-wire [2:0] cpuFC;
-wire [7:0] cpuAddrHi;
-wire [23:0] cpuAddr;
-wire [15:0] cpuDataOut;
-
-// RAM/ROM
-wire _romOE;
-wire _ramOE, _ramWE;
-wire _memoryUDS, _memoryLDS;
-wire videoBusControl;
-wire dioBusControl;
-wire cpuBusControl;
-wire [21:0] memoryAddr;
-wire [15:0] memoryDataOut;
-wire memoryLatch;
-
-// peripherals
-wire vid_alt, loadPixels, pixelOut, _hblank, _vblank, hsync, vsync;
-wire memoryOverlayOn, selectSCSI, selectSCC, selectIWM, selectVIA, selectRAM, selectROM, selectSEOverlay;
-wire [15:0] dataControllerDataOut;
-
-// audio
-wire snd_alt;
-wire loadSound;
-
-// floppy disk image interface
-wire dskReadAckInt;
-wire [21:0] dskReadAddrInt;
-wire dskReadAckExt;
-wire [21:0] dskReadAddrExt;
-
-// dtack generation in turbo mode
-reg  turbo_dtack_en, cpuBusControl_d;
-always @(posedge clk_sys) begin
-	if (!_cpuReset) begin
-		turbo_dtack_en <= 0;
-	end
-	else begin
-		cpuBusControl_d <= cpuBusControl;
-		if (_cpuAS) turbo_dtack_en <= 0;
-		if (!_cpuAS & ((!cpuBusControl_d & cpuBusControl) | (!selectROM & !selectRAM))) turbo_dtack_en <= 1;
-	end
-end
-
-assign      _cpuVPA = (cpuFC == 3'b111) ? 1'b0 : ~(!_cpuAS && cpuAddr[23:21] == 3'b111);
-assign      _cpuDTACK = ~(!_cpuAS && cpuAddr[23:21] != 3'b111) | (status_turbo & !turbo_dtack_en);
-
-wire        cpu_en_p      = status_turbo ? clk16_en_p : clk8_en_p;
-wire        cpu_en_n      = status_turbo ? clk16_en_n : clk8_en_n;
-
-wire        is68000       = status_cpu == 0;
-assign      _cpuReset_o   = is68000 ? fx68_reset_n : tg68_reset_n;
-assign      _cpuRW        = is68000 ? fx68_rw : tg68_rw;
-assign      _cpuAS        = is68000 ? fx68_as_n : tg68_as_n;
-assign      _cpuUDS       = is68000 ? fx68_uds_n : tg68_uds_n;
-assign      _cpuLDS       = is68000 ? fx68_lds_n : tg68_lds_n;
-assign      E_falling     = is68000 ? fx68_E_falling : tg68_E_falling;
-assign      E_rising      = is68000 ? fx68_E_rising : tg68_E_rising;
-assign      _cpuVMA       = is68000 ? fx68_vma_n : tg68_vma_n;
-assign      cpuFC[0]      = is68000 ? fx68_fc0 : tg68_fc0;
-assign      cpuFC[1]      = is68000 ? fx68_fc1 : tg68_fc1;
-assign      cpuFC[2]      = is68000 ? fx68_fc2 : tg68_fc2;
-assign      cpuAddr[23:1] = is68000 ? fx68_a : tg68_a[23:1];
-assign      cpuDataOut    = is68000 ? fx68_dout : tg68_dout;
-
-wire        fx68_rw;
-wire        fx68_as_n;
-wire        fx68_uds_n;
-wire        fx68_lds_n;
-wire        fx68_E_falling;
-wire        fx68_E_rising;
-wire        fx68_vma_n;
-wire        fx68_fc0;
-wire        fx68_fc1;
-wire        fx68_fc2;
-wire [15:0] fx68_dout;
-wire [23:1] fx68_a;
-wire        fx68_reset_n;
-
-fx68k fx68k (
-	.clk        ( clk_sys ),
-	.extReset   ( !_cpuReset ),
-	.pwrUp      ( !_cpuReset ),
-	.enPhi1     ( cpu_en_p   ),
-	.enPhi2     ( cpu_en_n   ),
-
-	.eRWn       ( fx68_rw ),
-	.ASn        ( fx68_as_n ),
-	.LDSn       ( fx68_lds_n ),
-	.UDSn       ( fx68_uds_n ),
-	.E          ( ),
-	.E_div      ( status_turbo ),
-	.E_PosClkEn ( fx68_E_falling ),
-	.E_NegClkEn ( fx68_E_rising ),
-	.VMAn       ( fx68_vma_n ),
-	.FC0        ( fx68_fc0 ),
-	.FC1        ( fx68_fc1 ),
-	.FC2        ( fx68_fc2 ),
-	.BGn        ( ),
-	.oRESETn    ( fx68_reset_n ),
-	.oHALTEDn   ( ),
-	.DTACKn     ( _cpuDTACK ),
-	.VPAn       ( _cpuVPA ),
-	.HALTn      ( 1'b1 ),
-	.BERRn      ( 1'b1 ),
-	.BRn        ( 1'b1 ),
-	.BGACKn     ( 1'b1 ),
-	.IPL0n      ( _cpuIPL[0] ),
-	.IPL1n      ( _cpuIPL[1] ),
-	.IPL2n      ( _cpuIPL[2] ),
-	.iEdb       ( dataControllerDataOut ),
-	.oEdb       ( fx68_dout ),
-	.eab        ( fx68_a )
-);
-
-wire        tg68_rw;
-wire        tg68_as_n;
-wire        tg68_uds_n;
-wire        tg68_lds_n;
-wire        tg68_E_rising;
-wire        tg68_E_falling;
-wire        tg68_vma_n;
-wire        tg68_fc0;
-wire        tg68_fc1;
-wire        tg68_fc2;
-wire [15:0] tg68_dout;
-wire [31:0] tg68_a;
-wire        tg68_reset_n;
-
-tg68k tg68k (
-	.clk        ( clk_sys      ),
-	.reset      ( !_cpuReset ),
-	.phi1       ( cpu_en_p  ),
-	.phi2       ( cpu_en_n  ),
-	.cpu        ( {status_cpu[1], |status_cpu} ),
-
-	.dtack_n    ( _cpuDTACK  ),
-	.rw_n       ( tg68_rw    ),
-	.as_n       ( tg68_as_n  ),
-	.uds_n      ( tg68_uds_n ),
-	.lds_n      ( tg68_lds_n ),
-	.fc         ( { tg68_fc2, tg68_fc1, tg68_fc0 } ),
-	.reset_n    ( tg68_reset_n ),
-
-	.E          (  ),
-	.E_div      ( status_turbo ),
-	.E_PosClkEn ( tg68_E_falling ),
-	.E_NegClkEn ( tg68_E_rising  ),
-	.vma_n      ( tg68_vma_n ),
-	.vpa_n      ( _cpuVPA ),
-
-	.br_n       ( 1'b1    ),
-	.bg_n       (  ),
-	.bgack_n    ( 1'b1 ),
-
-	.ipl        ( _cpuIPL ),
-	.berr       ( 1'b0 ),
-	.din        ( dataControllerDataOut ),
-	.dout       ( tg68_dout ),
-	.addr       ( tg68_a )
-);
-
-addrController_top ac0
-(
-	.clk(clk_sys),
-	.clk8(clk8),
-	.clk8_en_p(clk8_en_p),
-	.clk8_en_n(clk8_en_n),
-	.clk16_en_p(clk16_en_p),
-	.clk16_en_n(clk16_en_n),
-	.cpuAddr(cpuAddr), 
-	._cpuUDS(_cpuUDS),
-	._cpuLDS(_cpuLDS),
-	._cpuRW(_cpuRW),
-	._cpuAS(_cpuAS),
-	.turbo(status_turbo),
-	.configROMSize({status_mod,~status_mod}),
-	.configRAMSize(configRAMSize), 
-	.memoryAddr(memoryAddr),
-	.memoryLatch(memoryLatch),
-	._memoryUDS(_memoryUDS),
-	._memoryLDS(_memoryLDS),
-	._romOE(_romOE), 
-	._ramOE(_ramOE), 
-	._ramWE(_ramWE),
-	.videoBusControl(videoBusControl),	
-	.dioBusControl(dioBusControl),	
-	.cpuBusControl(cpuBusControl),	
-	.selectSCSI(selectSCSI),
-	.selectSCC(selectSCC),
-	.selectIWM(selectIWM),
-	.selectVIA(selectVIA),
-	.selectRAM(selectRAM),
-	.selectROM(selectROM),
-	.selectSEOverlay(selectSEOverlay),
-	.hsync(hsync), 
-	.vsync(vsync),
-	._hblank(_hblank),
-	._vblank(_vblank),
-	.loadPixels(loadPixels),
-	.vid_alt(vid_alt),
-	.memoryOverlayOn(memoryOverlayOn),
-
-	.snd_alt(snd_alt),
-	.loadSound(loadSound),
-
-	.dskReadAddrInt(dskReadAddrInt),
-	.dskReadAckInt(dskReadAckInt),
-	.dskReadAddrExt(dskReadAddrExt),
-	.dskReadAckExt(dskReadAckExt)
-);
-
-wire [1:0] diskEject;
-wire [1:0] diskMotor, diskAct;
-
-dataController_top #(SCSI_DEVS) dc0
-(
-	.clk32(clk_sys), 
-	.clk8_en_p(clk8_en_p),
-	.clk8_en_n(clk8_en_n),
-	.E_rising(E_rising),
-	.E_falling(E_falling),
-	.machineType(status_mod),
-	._systemReset(n_reset),
-	._cpuReset(_cpuReset), 
-	._cpuIPL(_cpuIPL),
-	._cpuUDS(_cpuUDS), 
-	._cpuLDS(_cpuLDS), 
-	._cpuRW(_cpuRW), 
-	._cpuVMA(_cpuVMA),
-	.cpuDataIn(cpuDataOut),
-	.cpuDataOut(dataControllerDataOut), 	
-	.cpuAddrRegHi(cpuAddr[12:9]),
-	.cpuAddrRegMid(cpuAddr[6:4]),  // for SCSI
-	.cpuAddrRegLo(cpuAddr[2:1]),		
-	.selectSCSI(selectSCSI),
-	.selectSCC(selectSCC),
-	.selectIWM(selectIWM),
-	.selectVIA(selectVIA),
-	.selectSEOverlay(selectSEOverlay),
-	.cpuBusControl(cpuBusControl),
-	.videoBusControl(videoBusControl),
-	.memoryDataOut(memoryDataOut),
-	.memoryDataIn(sdram_do),
-	.memoryLatch(memoryLatch),
-
-	// peripherals
-	.ps2_key(ps2_key), 
-	.capslock(capslock),
-	.ps2_mouse(ps2_mouse),
-	// serial uart
-	.serialIn(serialIn),
-	.serialOut(serialOut),
-	.serialCTS(serialCTS),
-	.serialRTS(serialRTS),
-
-	// rtc unix ticks
-	.timestamp(TIMESTAMP),
-
-	// video
-	._hblank(_hblank),
-	._vblank(_vblank), 
-	.pixelOut(pixelOut),
-	.loadPixels(loadPixels),
-	.vid_alt(vid_alt),
-
-	.memoryOverlayOn(memoryOverlayOn),
-
-	.audioOut(audio),
-	.snd_alt(snd_alt),
-	.loadSound(loadSound),
-
-	// floppy disk interface
-	.insertDisk({dsk_ext_ins, dsk_int_ins}),
-	.diskSides({dsk_ext_ds, dsk_int_ds}),
-	.diskEject(diskEject),
-	.dskReadAddrInt(dskReadAddrInt),
-	.dskReadAckInt(dskReadAckInt),
-	.dskReadAddrExt(dskReadAddrExt),
-	.dskReadAckExt(dskReadAckExt),
-	.diskMotor(diskMotor),
-	.diskAct(diskAct),
-
-	// block device interface for scsi disk
-	.img_mounted(img_mounted),
-	.img_size(img_size[40:9]),
-	.io_lba(sd_lba),
-	.io_rd(sd_rd),
-	.io_wr(sd_wr),
-	.io_ack(sd_ack),
-
-	.sd_buff_addr(sd_buff_addr),
-	.sd_buff_dout(sd_buff_dout),
-	.sd_buff_din(sd_buff_din),
-	.sd_buff_wr(sd_buff_wr)
-);
-
-reg disk_act;
-always @(posedge clk_sys) begin
-	integer timeout = 0;
-
-	if(timeout) begin
-		timeout <= timeout - 1;
-		disk_act <= 1;
-	end else begin
-		disk_act <= 0;
-	end
-
-	if(|diskAct) timeout <= 500000;
-end
-
-//////////////////////// DOWNLOADING ///////////////////////////
-
-// include ROM download helper
-wire dio_download;
-wire [23:0] dio_addr = ioctl_addr[24:1];
-wire  [7:0] dio_index;
-
-// good floppy image sizes are 819200 bytes and 409600 bytes
-reg dsk_int_ds, dsk_ext_ds;  // double sided image inserted
-reg dsk_int_ss, dsk_ext_ss;  // single sided image inserted
-
-// any known type of disk image inserted?
-wire dsk_int_ins = dsk_int_ds || dsk_int_ss;
-wire dsk_ext_ins = dsk_ext_ds || dsk_ext_ss;
-
-// at the end of a download latch file size
-// diskEject is set by macos on eject
-always @(posedge clk_sys) begin
-	reg old_down;
-
-	old_down <= dio_download;
-	if(old_down && ~dio_download && dio_index == 1) begin
-		dsk_int_ds <= (dio_addr == 409600);   // double sides disk, addr counts words, not bytes
-		dsk_int_ss <= (dio_addr == 204800);   // single sided disk
-	end
-
-	if(diskEject[0]) begin
-		dsk_int_ds <= 0;
-		dsk_int_ss <= 0;
-	end
-end	
-
-always @(posedge clk_sys) begin
-	reg old_down;
-
-	old_down <= dio_download;
-	if(old_down && ~dio_download && dio_index == 2) begin
-		dsk_ext_ds <= (dio_addr == 409600);   // double sided disk, addr counts words, not bytes
-		dsk_ext_ss <= (dio_addr == 204800);   // single sided disk
-	end
-
-	if(diskEject[1]) begin
-		dsk_ext_ds <= 0;
-		dsk_ext_ss <= 0;
-	end
-end
-
-// disk images are being stored right after os rom at word offset 0x80000 and 0x100000 
-reg [20:0] dio_a;
-reg [15:0] dio_data;
-reg        dio_write;
-
-always @(posedge clk_sys) begin
-	reg old_cyc = 0;
-	
-	if(ioctl_write) begin
-		dio_data <= {ioctl_data[7:0], ioctl_data[15:8]};
-		dio_a <= dio_index[1:0] ? {dio_index[1:0], dio_addr[18:0]} : {dio_index[6], dio_addr[17:0]};
-		ioctl_wait <= 1;
-	end
-
-	old_cyc <= dioBusControl;
-	if(~dioBusControl) dio_write <= ioctl_wait;
-	if(old_cyc & ~dioBusControl & dio_write) ioctl_wait <= 0;
-end
-
-
-// sdram used for ram/rom maps directly into 68k address space
-wire download_cycle = dio_download && dioBusControl;
-
-////////////////////////// SDRAM /////////////////////////////////
-
-wire [24:0] sdram_addr = download_cycle ? {4'b0001, dio_a[20:0] } : 
-                         ~_romOE        ? {4'b0001, 2'b00, status_mod, memoryAddr[18:1]} :
-                                          {3'b000, (dskReadAckInt || dskReadAckExt), memoryAddr[21:1]};
-
-wire [15:0] sdram_din  = download_cycle ? dio_data              : memoryDataOut;
-wire  [1:0] sdram_ds   = download_cycle ? 2'b11                 : { !_memoryUDS, !_memoryLDS };
-wire        sdram_we   = download_cycle ? dio_write             : !_ramWE;
-wire        sdram_oe   = download_cycle ? 1'b0                  : (!_ramOE || !_romOE || dskReadAckInt || dskReadAckExt);
-wire [15:0] sdram_do   = download_cycle ? 16'hffff : (dskReadAckInt || dskReadAckExt) ? extra_rom_data_demux : sdram_out;
-
-// during rom/disk download ffff is returned so the screen is black during download
-// "extra rom" is used to hold the disk image. It's expected to be byte wide and
-// we thus need to properly demultiplex the word returned from sdram in that case
-wire [15:0] extra_rom_data_demux = memoryAddr[0]? {sdram_out[7:0],sdram_out[7:0]}:{sdram_out[15:8],sdram_out[15:8]};
-wire [15:0] sdram_out;
-
-assign SDRAM_CKE = 1;
-
-sdram sdram
-(
-	// system interface
-	.init           ( !pll_locked              ),
-	.clk_64         ( clk_mem                  ),
-	.clk_8          ( clk8                     ),
-
-	.sd_clk         ( SDRAM_CLK                ),
-	.sd_data        ( SDRAM_DQ                 ),
-	.sd_addr        ( SDRAM_A                  ),
-	.sd_dqm         ( {SDRAM_DQMH, SDRAM_DQML} ),
-	.sd_cs          ( SDRAM_nCS                ),
-	.sd_ba          ( SDRAM_BA                 ),
-	.sd_we          ( SDRAM_nWE                ),
-	.sd_ras         ( SDRAM_nRAS               ),
-	.sd_cas         ( SDRAM_nCAS               ),
-
-	// cpu/chipset interface
-	// map rom to sdram word address $200000 - $20ffff
-	.din            ( sdram_din                ),
-	.addr           ( sdram_addr               ),
-	.ds             ( sdram_ds                 ),
-	.we             ( sdram_we                 ),
-	.oe             ( sdram_oe                 ),
-	.dout           ( sdram_out                )
-);
-
-endmodule
+
+`ifdef MISTER_FB
+	// Use framebuffer in DDRAM
+	// FB_FORMAT:
+	//    [2:0] : 011=8bpp(palette) 100=16bpp 101=24bpp 110=32bpp
+	//    [3]   : 0=16bits 565 1=16bits 1555
+	//    [4]   : 0=RGB  1=BGR (for 16/24/32 modes)
+	//
+	// FB_STRIDE either 0 (rounded to 256 bytes) or multiple of pixel size (in bytes)
+	output        FB_EN,
+	output  [4:0] FB_FORMAT,
+	output [11:0] FB_WIDTH,
+	output [11:0] FB_HEIGHT,
+	output [31:0] FB_BASE,
+	output [13:0] FB_STRIDE,
+	input         FB_VBL,
+	input         FB_LL,
+	output        FB_FORCE_BLANK,
+
+`ifdef MISTER_FB_PALETTE
+	// Palette control for 8bit modes.
+	// Ignored for other video modes.
+	output        FB_PAL_CLK,
+	output  [7:0] FB_PAL_ADDR,
+	output [23:0] FB_PAL_DOUT,
+	input  [23:0] FB_PAL_DIN,
+	output        FB_PAL_WR,
+`endif
+`endif
+
+	output        LED_USER,  // 1 - ON, 0 - OFF.
+
+	// b[1]: 0 - LED status is system status OR'd with b[0]
+	//       1 - LED status is controled solely by b[0]
+	// hint: supply 2'b00 to let the system control the LED.
+	output  [1:0] LED_POWER,
+	output  [1:0] LED_DISK,
+
+	// I/O board button press simulation (active high)
+	// b[1]: user button
+	// b[0]: osd button
+	output  [1:0] BUTTONS,
+
+	input         CLK_AUDIO, // 24.576 MHz
+	output [15:0] AUDIO_L,
+	output [15:0] AUDIO_R,
+	output        AUDIO_S,   // 1 - signed audio samples, 0 - unsigned
+	output  [1:0] AUDIO_MIX, // 0 - no mix, 1 - 25%, 2 - 50%, 3 - 100% (mono)
+
+	//ADC
+	inout   [3:0] ADC_BUS,
+
+	//SD-SPI
+	output        SD_SCK,
+	output        SD_MOSI,
+	input         SD_MISO,
+	output        SD_CS,
+	input         SD_CD,
+
+	//High latency DDR3 RAM interface
+	//Use for non-critical time purposes
+	output        DDRAM_CLK,
+	input         DDRAM_BUSY,
+	output  [7:0] DDRAM_BURSTCNT,
+	output [28:0] DDRAM_ADDR,
+	input  [63:0] DDRAM_DOUT,
+	input         DDRAM_DOUT_READY,
+	output        DDRAM_RD,
+	output [63:0] DDRAM_DIN,
+	output  [7:0] DDRAM_BE,
+	output        DDRAM_WE,
+
+	//SDRAM interface with lower latency
+	output        SDRAM_CLK,
+	output        SDRAM_CKE,
+	output [12:0] SDRAM_A,
+	output  [1:0] SDRAM_BA,
+	inout  [15:0] SDRAM_DQ,
+	output        SDRAM_DQML,
+	output        SDRAM_DQMH,
+	output        SDRAM_nCS,
+	output        SDRAM_nCAS,
+	output        SDRAM_nRAS,
+	output        SDRAM_nWE,
+
+`ifdef MISTER_DUAL_SDRAM
+	//Secondary SDRAM
+	//Set all output SDRAM_* signals to Z ASAP if SDRAM2_EN is 0
+	input         SDRAM2_EN,
+	output        SDRAM2_CLK,
+	output [12:0] SDRAM2_A,
+	output  [1:0] SDRAM2_BA,
+	inout  [15:0] SDRAM2_DQ,
+	output        SDRAM2_nCS,
+	output        SDRAM2_nCAS,
+	output        SDRAM2_nRAS,
+	output        SDRAM2_nWE,
+`endif
+
+	input         UART_CTS,
+	output        UART_RTS,
+	input         UART_RXD,
+	output        UART_TXD,
+	output        UART_DTR,
+	input         UART_DSR,
+
+	// Open-drain User port.
+	// 0 - D+/RX
+	// 1 - D-/TX
+	// 2..6 - USR2..USR6
+	// Set USER_OUT to 1 to read from USER_IN.
+	input   [6:0] USER_IN,
+	output  [6:0] USER_OUT,
+
+	input         OSD_STATUS
+);
+
+assign ADC_BUS  = 'Z;
+assign USER_OUT = '1;
+
+assign {DDRAM_CLK, DDRAM_BURSTCNT, DDRAM_ADDR, DDRAM_DIN, DDRAM_BE, DDRAM_RD, DDRAM_WE} = 0;
+assign {SD_SCK, SD_MOSI, SD_CS} = 'Z;
+
+assign LED_USER  = dio_download || (disk_act ^ |diskMotor);
+assign LED_DISK  = 0;
+assign LED_POWER = 0;
+assign BUTTONS   = 0;
+assign VGA_SCALER= 0;
+assign VGA_DISABLE = 0;
+assign HDMI_FREEZE = 0;
+assign HDMI_BLACKOUT = 0;
+assign HDMI_BOB_DEINT = 0;
+
+wire [1:0] ar = status[8:7];
+video_freak video_freak
+(
+	.*,
+	.VGA_DE_IN(VGA_DE),
+	.VGA_DE(),
+
+	.ARX((!ar) ? 12'd256 : (ar - 1'd1)),
+	.ARY((!ar) ? 12'd171 : 12'd0),
+	.CROP_SIZE(0),
+	.CROP_OFF(0),
+	.SCALE(status[12:11])
+);
+
+`include "build_id.v"
+localparam CONF_STR = {
+	"MACPLUS;UART115200;",
+	"-;",
+	"F1,DSK,Mount Pri Floppy;",
+	"F2,DSK,Mount Sec Floppy;",
+	"-;",
+	"SC0,IMGVHD,Mount SCSI-6;",
+	"SC1,IMGVHD,Mount SCSI-5;",
+	"-;",
+	"O78,Aspect ratio,Original,Full Screen,[ARC1],[ARC2];",
+	"OBC,Scale,Normal,V-Integer,Narrower HV-Integer,Wider HV-Integer;",
+	"-;",
+	"O9A,Model,Plus,SE,Macintosh II;",
+	"O5,Speed,8MHz,16MHz;",
+	"ODE,CPU,68000,68010,68020;",
+	"O4,Memory,1MB,4MB;",
+	"S4,ROM,Load NuBus Video ROM;",
+	"-;",
+	//"OA,Serial,Off,On;",
+	//"-;",
+	"R0,Reset & Apply CPU+Memory;",
+	"v,0;", // [optional] config version 0-99.
+	        // If CONF_STR options are changed in incompatible way, then change version number too,
+			// so all options will get default values on first start.
+	"V,v",`BUILD_DATE
+};
+
+wire status_turbo = status[5];
+
+////////////////////   CLOCKS   ///////////////////
+
+wire clk_sys, clk_mem;
+wire pll_locked;
+
+pll pll
+(
+	.refclk(CLK_50M),
+	.outclk_0(clk_mem),
+	.outclk_1(clk_sys),
+	.locked(pll_locked)
+);
+
+reg       status_mem;
+reg [1:0] status_cpu;
+reg [1:0] status_mod;
+reg       n_reset = 0;
+always @(posedge clk_sys) begin
+	reg [15:0] rst_cnt;
+
+	if (clk8_en_p) begin
+		// various sources can reset the mac
+		if(~pll_locked || status[0] || buttons[1] || RESET || ~_cpuReset_o) begin
+			rst_cnt <= '1;
+			n_reset <= 0;
+		end
+		else if(rst_cnt) begin
+			rst_cnt    <= rst_cnt - 1'd1;
+			status_mem <= status[4];
+			status_cpu <= status[14:13];
+			status_mod <= status[10:9];
+		end
+		else begin
+			n_reset <= 1;
+		end
+	end
+end
+
+///////////////////////////////////////////////////
+
+localparam SCSI_DEVS = 2;
+
+// the status register is controlled by the on screen display (OSD)
+wire [31:0] status;
+wire  [1:0] buttons;
+wire [31:0] sd_lba[SCSI_DEVS];
+wire  [SCSI_DEVS-1:0] sd_rd;
+wire  [SCSI_DEVS-1:0] sd_wr;
+wire  [SCSI_DEVS-1:0] sd_ack;
+wire            [7:0] sd_buff_addr;
+wire           [15:0] sd_buff_dout;
+wire           [15:0] sd_buff_din[SCSI_DEVS];
+wire                  sd_buff_wr;
+wire  [SCSI_DEVS-1:0] img_mounted;
+wire           [63:0] img_size;
+
+wire        ioctl_write;
+reg         ioctl_wait = 0;
+
+wire [10:0] ps2_key;
+wire [24:0] ps2_mouse;
+wire        capslock;
+
+wire [24:0] ioctl_addr;
+wire [15:0] ioctl_data;
+
+wire [32:0] TIMESTAMP;
+
+hps_io #(.CONF_STR(CONF_STR), .VDNUM(SCSI_DEVS), .WIDE(1)) hps_io
+(
+	.clk_sys(clk_sys),
+	.HPS_BUS(HPS_BUS),
+
+	.buttons(buttons),
+	.status(status),
+
+	.sd_lba(sd_lba),
+	.sd_rd(sd_rd),
+	.sd_wr(sd_wr),
+	.sd_ack(sd_ack),
+
+	.sd_buff_addr(sd_buff_addr),
+	.sd_buff_dout(sd_buff_dout),
+	.sd_buff_din(sd_buff_din),
+	.sd_buff_wr(sd_buff_wr),
+
+	.img_mounted(img_mounted),
+	.img_size(img_size),
+
+	.ioctl_download(dio_download),
+	.ioctl_index(dio_index),
+	.ioctl_wr(ioctl_write),
+	.ioctl_addr(ioctl_addr),
+	.ioctl_dout(ioctl_data),
+	.ioctl_wait(ioctl_wait),
+
+	.TIMESTAMP(TIMESTAMP),
+
+	.ps2_key(ps2_key),
+	.ps2_kbd_led_use(3'b001),
+	.ps2_kbd_led_status({2'b00, capslock}),
+
+	.ps2_mouse(ps2_mouse)
+);
+
+assign CLK_VIDEO = clk_sys;
+assign CE_PIXEL  = 1;
+
+wire [15:0] nubusDataOut;
+wire nubusAck;
+wire nubus_irq_n;
+wire [7:0] nubus_r, nubus_g, nubus_b;
+wire nubus_hs, nubus_vs, nubus_blank;
+
+wire video_from_nubus = (status_mod == 2'd2); // Mac II mode uses NuBus video
+
+assign VGA_R  = video_from_nubus ? nubus_r : {8{pixelOut}};
+assign VGA_G  = video_from_nubus ? nubus_g : {8{pixelOut}};
+assign VGA_B  = video_from_nubus ? nubus_b : {8{pixelOut}};
+assign VGA_DE = video_from_nubus ? !nubus_blank : (_vblank & _hblank);
+assign VGA_VS = video_from_nubus ? nubus_vs : vsync;
+assign VGA_HS = video_from_nubus ? nubus_hs : hsync;
+assign VGA_F1 = 0;
+assign VGA_SL = 0;
+
+wire [10:0] audio;
+assign AUDIO_L = {audio[10:0], 5'b00000};
+assign AUDIO_R = {audio[10:0], 5'b00000};
+assign AUDIO_S = 1;
+assign AUDIO_MIX = 0;
+
+
+// ------------------------------ Plus Too Bus Timing ---------------------------------
+// for stability and maintainability reasons the whole timing has been simplyfied:
+//                00           01             10           11
+//    ______ _____________ _____________ _____________ _____________ ___
+//    ______X_video_cycle_X__cpu_cycle__X__IO_cycle___X__cpu_cycle__X___
+//                        ^      ^    ^                      ^    ^
+//                        |      |    |                      |    |
+//                      video    | CPU|                      | CPU|
+//                       read   write read                  write read
+
+
+
+// set the real-world inputs to sane defaults
+localparam 	  configROMSize = 1'b1;  // 128K ROM
+
+wire [1:0] configRAMSize = status_mem?2'b11:2'b10; // 1MB/4MB
+wire selectNuBus;
+
+//
+// Serial Ports
+//
+wire serialOut;
+wire serialIn;
+wire serialCTS;
+wire serialRTS;
+
+/*
+assign serialIn = ~status[10] ? 0 : UART_RXD;
+assign UART_TXD = serialOut;
+assign serialCTS = UART_CTS;
+assign UART_RTS = serialRTS;
+assign UART_DTR = UART_DSR;
+*/
+
+//assign serialIn = ~status[10] ? 0 : UART_RXD;
+assign serialIn =  UART_RXD;
+assign UART_TXD = serialOut;
+//assign UART_RTS = UART_CTS;
+assign UART_RTS = serialRTS ;
+assign UART_DTR = UART_DSR;
+
+//assign {UART_RTS, UART_TXD, UART_DTR} = 0;
+/*
+	input         UART_CTS,
+	output        UART_RTS,
+	input         UART_RXD,
+	output        UART_TXD,
+	output        UART_DTR,
+	input         UART_DSR,
+*/
+
+
+// interconnects
+// CPU
+wire clk8, _cpuReset, _cpuReset_o, _cpuUDS, _cpuLDS, _cpuRW, _cpuAS;
+wire clk8_en_p, clk8_en_n;
+wire clk16_en_p, clk16_en_n;
+wire _cpuVMA, _cpuVPA, _cpuDTACK;
+wire E_rising, E_falling;
+wire [2:0] _cpuIPL;
+wire [2:0] cpuFC;
+wire [7:0] cpuAddrHi;
+wire [31:0] cpuAddr;
+wire [15:0] cpuDataOut;
+
+// RAM/ROM
+wire _romOE;
+wire _ramOE, _ramWE;
+wire _memoryUDS, _memoryLDS;
+wire videoBusControl;
+wire dioBusControl;
+wire cpuBusControl;
+wire [21:0] memoryAddr;
+wire [15:0] memoryDataOut;
+wire memoryLatch;
+
+// peripherals
+wire vid_alt, loadPixels, pixelOut, _hblank, _vblank, hsync, vsync;
+wire memoryOverlayOn, selectSCSI, selectSCC, selectIWM, selectVIA, selectRAM, selectROM, selectSEOverlay;
+wire [15:0] dataControllerDataOut;
+
+// audio
+wire snd_alt;
+wire loadSound;
+
+// floppy disk image interface
+wire dskReadAckInt;
+wire [21:0] dskReadAddrInt;
+wire dskReadAckExt;
+wire [21:0] dskReadAddrExt;
+
+// dtack generation in turbo mode
+reg  turbo_dtack_en, cpuBusControl_d;
+always @(posedge clk_sys) begin
+	if (!_cpuReset) begin
+		turbo_dtack_en <= 0;
+	end
+	else begin
+		cpuBusControl_d <= cpuBusControl;
+		if (_cpuAS) turbo_dtack_en <= 0;
+		if (!_cpuAS & ((!cpuBusControl_d & cpuBusControl) | (!selectROM & !selectRAM))) turbo_dtack_en <= 1;
+	end
+end
+
+assign      _cpuVPA = (cpuFC == 3'b111) ? 1'b0 : ~(!_cpuAS && cpuAddr[23:21] == 3'b111);
+assign      _cpuDTACK = selectNuBus ? nubusAck : (~(!_cpuAS && cpuAddr[23:21] != 3'b111) | (status_turbo & !turbo_dtack_en));
+
+wire        cpu_en_p      = status_turbo ? clk16_en_p : clk8_en_p;
+wire        cpu_en_n      = status_turbo ? clk16_en_n : clk8_en_n;
+
+wire        is68000       = status_cpu == 0;
+assign      _cpuReset_o   = is68000 ? fx68_reset_n : tg68_reset_n;
+assign      _cpuRW        = is68000 ? fx68_rw : tg68_rw;
+assign      _cpuAS        = is68000 ? fx68_as_n : tg68_as_n;
+assign      _cpuUDS       = is68000 ? fx68_uds_n : tg68_uds_n;
+assign      _cpuLDS       = is68000 ? fx68_lds_n : tg68_lds_n;
+assign      E_falling     = is68000 ? fx68_E_falling : tg68_E_falling;
+assign      E_rising      = is68000 ? fx68_E_rising : tg68_E_rising;
+assign      _cpuVMA       = is68000 ? fx68_vma_n : tg68_vma_n;
+assign      cpuFC[0]      = is68000 ? fx68_fc0 : tg68_fc0;
+assign      cpuFC[1]      = is68000 ? fx68_fc1 : tg68_fc1;
+assign      cpuFC[2]      = is68000 ? fx68_fc2 : tg68_fc2;
+assign      cpuAddr       = is68000 ? {8'h00, fx68_a, 1'b0} : tg68_a;
+assign      cpuDataOut    = is68000 ? fx68_dout : tg68_dout;
+
+wire        fx68_rw;
+wire        fx68_as_n;
+wire        fx68_uds_n;
+wire        fx68_lds_n;
+wire        fx68_E_falling;
+wire        fx68_E_rising;
+wire        fx68_vma_n;
+wire        fx68_fc0;
+wire        fx68_fc1;
+wire        fx68_fc2;
+wire [15:0] fx68_dout;
+wire [23:1] fx68_a;
+wire        fx68_reset_n;
+
+fx68k fx68k (
+	.clk        ( clk_sys ),
+	.extReset   ( !_cpuReset ),
+	.pwrUp      ( !_cpuReset ),
+	.enPhi1     ( cpu_en_p   ),
+	.enPhi2     ( cpu_en_n   ),
+
+	.eRWn       ( fx68_rw ),
+	.ASn        ( fx68_as_n ),
+	.LDSn       ( fx68_lds_n ),
+	.UDSn       ( fx68_uds_n ),
+	.E          ( ),
+	.E_div      ( status_turbo ),
+	.E_PosClkEn ( fx68_E_falling ),
+	.E_NegClkEn ( fx68_E_rising ),
+	.VMAn       ( fx68_vma_n ),
+	.FC0        ( fx68_fc0 ),
+	.FC1        ( fx68_fc1 ),
+	.FC2        ( fx68_fc2 ),
+	.BGn        ( ),
+	.oRESETn    ( fx68_reset_n ),
+	.oHALTEDn   ( ),
+	.DTACKn     ( _cpuDTACK ),
+	.VPAn       ( _cpuVPA ),
+	.HALTn      ( 1'b1 ),
+	.BERRn      ( 1'b1 ),
+	.BRn        ( 1'b1 ),
+	.BGACKn     ( 1'b1 ),
+	.IPL0n      ( _cpuIPL[0] ),
+	.IPL1n      ( _cpuIPL[1] ),
+	.IPL2n      ( _cpuIPL[2] ),
+	.iEdb       ( dataControllerDataOut ),
+	.oEdb       ( fx68_dout ),
+	.eab        ( fx68_a )
+);
+
+wire        tg68_rw;
+wire        tg68_as_n;
+wire        tg68_uds_n;
+wire        tg68_lds_n;
+wire        tg68_E_rising;
+wire        tg68_E_falling;
+wire        tg68_vma_n;
+wire        tg68_fc0;
+wire        tg68_fc1;
+wire        tg68_fc2;
+wire [15:0] tg68_dout;
+wire [31:0] tg68_a;
+wire        tg68_reset_n;
+
+tg68k tg68k (
+	.clk        ( clk_sys      ),
+	.reset      ( !_cpuReset ),
+	.phi1       ( cpu_en_p  ),
+	.phi2       ( cpu_en_n  ),
+	.cpu        ( {status_cpu[1], |status_cpu} ),
+
+	.dtack_n    ( _cpuDTACK  ),
+	.rw_n       ( tg68_rw    ),
+	.as_n       ( tg68_as_n  ),
+	.uds_n      ( tg68_uds_n ),
+	.lds_n      ( tg68_lds_n ),
+	.fc         ( { tg68_fc2, tg68_fc1, tg68_fc0 } ),
+	.reset_n    ( tg68_reset_n ),
+
+	.E          (  ),
+	.E_div      ( status_turbo ),
+	.E_PosClkEn ( tg68_E_falling ),
+	.E_NegClkEn ( tg68_E_rising  ),
+	.vma_n      ( tg68_vma_n ),
+	.vpa_n      ( _cpuVPA ),
+
+	.br_n       ( 1'b1    ),
+	.bg_n       (  ),
+	.bgack_n    ( 1'b1 ),
+
+	.ipl        ( _cpuIPL ),
+	.berr       ( 1'b0 ),
+	.din        ( dataControllerDataOut ),
+	.dout       ( tg68_dout ),
+	.addr       ( tg68_a )
+);
+
+addrController_top ac0
+(
+	.clk(clk_sys),
+	.clk8(clk8),
+	.clk8_en_p(clk8_en_p),
+	.clk8_en_n(clk8_en_n),
+	.clk16_en_p(clk16_en_p),
+	.clk16_en_n(clk16_en_n),
+	.cpuAddr(cpuAddr),
+	._cpuUDS(_cpuUDS),
+	._cpuLDS(_cpuLDS),
+	._cpuRW(_cpuRW),
+	._cpuAS(_cpuAS),
+	.turbo(status_turbo),
+	.configROMSize((status_mod == 0) ? 2'b01 : 2'b10), // 0=Plus(128K), 1=SE(256K), 2=MacII(256K)
+	.configRAMSize(configRAMSize),
+	.memoryAddr(memoryAddr),
+	.memoryLatch(memoryLatch),
+	._memoryUDS(_memoryUDS),
+	._memoryLDS(_memoryLDS),
+	._romOE(_romOE),
+	._ramOE(_ramOE),
+	._ramWE(_ramWE),
+	.videoBusControl(videoBusControl),
+	.dioBusControl(dioBusControl),
+	.cpuBusControl(cpuBusControl),
+	.selectSCSI(selectSCSI),
+	.selectSCC(selectSCC),
+	.selectIWM(selectIWM),
+	.selectVIA(selectVIA),
+	.selectRAM(selectRAM),
+	.selectROM(selectROM),
+	.selectSEOverlay(selectSEOverlay),
+	.selectNuBus(selectNuBus),
+	.hsync(hsync),
+	.vsync(vsync),
+	._hblank(_hblank),
+	._vblank(_vblank),
+	.loadPixels(loadPixels),
+	.vid_alt(vid_alt),
+	.memoryOverlayOn(memoryOverlayOn),
+
+	.snd_alt(snd_alt),
+	.loadSound(loadSound),
+
+	.dskReadAddrInt(dskReadAddrInt),
+	.dskReadAckInt(dskReadAckInt),
+	.dskReadAddrExt(dskReadAddrExt),
+	.dskReadAckExt(dskReadAckExt)
+);
+
+wire [1:0] diskEject;
+wire [1:0] diskMotor, diskAct;
+
+nubus_video nubus_card (
+	.clk(clk_sys),
+	.reset(!_cpuReset),
+	.addr(cpuAddr),
+	.data_in(cpuDataOut),
+	.data_out(nubusDataOut),
+	.uds_lds({!_cpuUDS, !_cpuLDS}),
+	.rw_n(_cpuRW),
+	.select(selectNuBus),
+	.ack_n(nubusAck),
+	.vga_r(nubus_r),
+	.vga_g(nubus_g),
+	.vga_b(nubus_b),
+	.vga_hs(nubus_hs),
+	.vga_vs(nubus_vs),
+	.vga_blank(nubus_blank),
+	.vga_clk(), // unused for now
+	.nmrq_n(nubus_irq_n),
+
+	.ioctl_wr(ioctl_write),
+	.ioctl_addr({4'd0, dio_a}),
+	.ioctl_data(dio_data),
+	.ioctl_download(dio_download),
+	.ioctl_index(dio_index)
+);
+
+dataController_top #(SCSI_DEVS) dc0
+(
+	.clk32(clk_sys),
+	.clk8_en_p(clk8_en_p),
+	.clk8_en_n(clk8_en_n),
+	.E_rising(E_rising),
+	.E_falling(E_falling),
+	.machineType(status_mod[0]),
+	._systemReset(n_reset),
+	._cpuReset(_cpuReset),
+	._cpuIPL(_cpuIPL),
+	._cpuUDS(_cpuUDS),
+	._cpuLDS(_cpuLDS),
+	._cpuRW(_cpuRW),
+	._cpuVMA(_cpuVMA),
+	.selectNuBus(selectNuBus),
+	.nubusDataIn(nubusDataOut),
+	.nubus_irq_n(nubus_irq_n),
+	.cpuDataIn(cpuDataOut),
+	.cpuDataOut(dataControllerDataOut),
+	.cpuAddrRegHi(cpuAddr[12:9]),
+	.cpuAddrRegMid(cpuAddr[6:4]),  // for SCSI
+	.cpuAddrRegLo(cpuAddr[2:1]),
+	.selectSCSI(selectSCSI),
+	.selectSCC(selectSCC),
+	.selectIWM(selectIWM),
+	.selectVIA(selectVIA),
+	.selectSEOverlay(selectSEOverlay),
+	.cpuBusControl(cpuBusControl),
+	.videoBusControl(videoBusControl),
+	.memoryDataOut(memoryDataOut),
+	.memoryDataIn(sdram_do),
+	.memoryLatch(memoryLatch),
+
+	// peripherals
+	.ps2_key(ps2_key),
+	.capslock(capslock),
+	.ps2_mouse(ps2_mouse),
+	// serial uart
+	.serialIn(serialIn),
+	.serialOut(serialOut),
+	.serialCTS(serialCTS),
+	.serialRTS(serialRTS),
+
+	// rtc unix ticks
+	.timestamp(TIMESTAMP),
+
+	// video
+	._hblank(_hblank),
+	._vblank(_vblank),
+	.pixelOut(pixelOut),
+	.loadPixels(loadPixels),
+	.vid_alt(vid_alt),
+
+	.memoryOverlayOn(memoryOverlayOn),
+
+	.audioOut(audio),
+	.snd_alt(snd_alt),
+	.loadSound(loadSound),
+
+	// floppy disk interface
+	.insertDisk({dsk_ext_ins, dsk_int_ins}),
+	.diskSides({dsk_ext_ds, dsk_int_ds}),
+	.diskEject(diskEject),
+	.dskReadAddrInt(dskReadAddrInt),
+	.dskReadAckInt(dskReadAckInt),
+	.dskReadAddrExt(dskReadAddrExt),
+	.dskReadAckExt(dskReadAckExt),
+	.diskMotor(diskMotor),
+	.diskAct(diskAct),
+
+	// block device interface for scsi disk
+	.img_mounted(img_mounted),
+	.img_size(img_size[40:9]),
+	.io_lba(sd_lba),
+	.io_rd(sd_rd),
+	.io_wr(sd_wr),
+	.io_ack(sd_ack),
+
+	.sd_buff_addr(sd_buff_addr),
+	.sd_buff_dout(sd_buff_dout),
+	.sd_buff_din(sd_buff_din),
+	.sd_buff_wr(sd_buff_wr)
+);
+
+reg disk_act;
+always @(posedge clk_sys) begin
+	integer timeout = 0;
+
+	if(timeout) begin
+		timeout <= timeout - 1;
+		disk_act <= 1;
+	end else begin
+		disk_act <= 0;
+	end
+
+	if(|diskAct) timeout <= 500000;
+end
+
+//////////////////////// DOWNLOADING ///////////////////////////
+
+// include ROM download helper
+wire dio_download;
+wire [23:0] dio_addr = ioctl_addr[24:1];
+wire  [7:0] dio_index;
+
+// good floppy image sizes are 819200 bytes and 409600 bytes
+reg dsk_int_ds, dsk_ext_ds;  // double sided image inserted
+reg dsk_int_ss, dsk_ext_ss;  // single sided image inserted
+
+// any known type of disk image inserted?
+wire dsk_int_ins = dsk_int_ds || dsk_int_ss;
+wire dsk_ext_ins = dsk_ext_ds || dsk_ext_ss;
+
+// at the end of a download latch file size
+// diskEject is set by macos on eject
+always @(posedge clk_sys) begin
+	reg old_down;
+
+	old_down <= dio_download;
+	if(old_down && ~dio_download && dio_index == 1) begin
+		dsk_int_ds <= (dio_addr == 409600);   // double sides disk, addr counts words, not bytes
+		dsk_int_ss <= (dio_addr == 204800);   // single sided disk
+	end
+
+	if(diskEject[0]) begin
+		dsk_int_ds <= 0;
+		dsk_int_ss <= 0;
+	end
+end
+
+always @(posedge clk_sys) begin
+	reg old_down;
+
+	old_down <= dio_download;
+	if(old_down && ~dio_download && dio_index == 2) begin
+		dsk_ext_ds <= (dio_addr == 409600);   // double sided disk, addr counts words, not bytes
+		dsk_ext_ss <= (dio_addr == 204800);   // single sided disk
+	end
+
+	if(diskEject[1]) begin
+		dsk_ext_ds <= 0;
+		dsk_ext_ss <= 0;
+	end
+end
+
+// disk images are being stored right after os rom at word offset 0x80000 and 0x100000
+reg [20:0] dio_a;
+reg [15:0] dio_data;
+reg        dio_write;
+
+always @(posedge clk_sys) begin
+	reg old_cyc = 0;
+
+	if(ioctl_write) begin
+		dio_data <= {ioctl_data[7:0], ioctl_data[15:8]};
+
+		if (dio_index == 3) // Mac II ROM (256K)
+			dio_a <= {3'b000, dio_addr[17:0]}; // Map to 0 (Slot 0 offset 0)
+		else
+			dio_a <= dio_index[1:0] ? {dio_index[1:0], dio_addr[18:0]} : {dio_index[6], dio_addr[17:0]};
+
+		ioctl_wait <= 1;
+	end
+
+	old_cyc <= dioBusControl;
+	if(~dioBusControl) dio_write <= ioctl_wait;
+	if(old_cyc & ~dioBusControl & dio_write) ioctl_wait <= 0;
+end
+
+
+// sdram used for ram/rom maps directly into 68k address space
+wire download_cycle = dio_download && dioBusControl;
+
+////////////////////////// SDRAM /////////////////////////////////
+
+// Status mod: 0=Plus, 1=SE, 2=MacII
+wire [24:0] sdram_addr = download_cycle ? {4'b0001, dio_a[20:0] } :
+                         ~_romOE        ? {4'b0001, 2'b00, status_mod[0], memoryAddr[18:1]} : // Mac II ROM also at 0 offset if mapped there
+                                          {3'b000, (dskReadAckInt || dskReadAckExt), memoryAddr[21:1]};
+
+wire [15:0] sdram_din  = download_cycle ? dio_data              : memoryDataOut;
+wire  [1:0] sdram_ds   = download_cycle ? 2'b11                 : { !_memoryUDS, !_memoryLDS };
+wire        sdram_we   = download_cycle ? dio_write             : !_ramWE;
+wire        sdram_oe   = download_cycle ? 1'b0                  : (!_ramOE || !_romOE || dskReadAckInt || dskReadAckExt);
+wire [15:0] sdram_do   = download_cycle ? 16'hffff : (dskReadAckInt || dskReadAckExt) ? extra_rom_data_demux : sdram_out;
+
+// during rom/disk download ffff is returned so the screen is black during download
+// "extra rom" is used to hold the disk image. It's expected to be byte wide and
+// we thus need to properly demultiplex the word returned from sdram in that case
+wire [15:0] extra_rom_data_demux = memoryAddr[0]? {sdram_out[7:0],sdram_out[7:0]}:{sdram_out[15:8],sdram_out[15:8]};
+wire [15:0] sdram_out;
+
+assign SDRAM_CKE = 1;
+
+sdram sdram
+(
+	// system interface
+	.init           ( !pll_locked              ),
+	.clk_64         ( clk_mem                  ),
+	.clk_8          ( clk8                     ),
+
+	.sd_clk         ( SDRAM_CLK                ),
+	.sd_data        ( SDRAM_DQ                 ),
+	.sd_addr        ( SDRAM_A                  ),
+	.sd_dqm         ( {SDRAM_DQMH, SDRAM_DQML} ),
+	.sd_cs          ( SDRAM_nCS                ),
+	.sd_ba          ( SDRAM_BA                 ),
+	.sd_we          ( SDRAM_nWE                ),
+	.sd_ras         ( SDRAM_nRAS               ),
+	.sd_cas         ( SDRAM_nCAS               ),
+
+	// cpu/chipset interface
+	// map rom to sdram word address $200000 - $20ffff
+	.din            ( sdram_din                ),
+	.addr           ( sdram_addr               ),
+	.ds             ( sdram_ds                 ),
+	.we             ( sdram_we                 ),
+	.oe             ( sdram_oe                 ),
+	.dout           ( sdram_out                )
+);
+
+endmodule
diff --git a/files.qip b/files.qip
index 885f1ed..a92eb2e 100644
--- a/files.qip
+++ b/files.qip
@@ -19,4 +19,5 @@ set_global_assignment -name SYSTEMVERILOG_FILE rtl/dataController_top.sv
 set_global_assignment -name VERILOG_FILE rtl/videoTimer.v
 set_global_assignment -name VERILOG_FILE rtl/videoShifter.v
 set_global_assignment -name VERILOG_FILE rtl/rtc.v 
+set_global_assignment -name SYSTEMVERILOG_FILE rtl/nubus/nubus_video.sv
 set_global_assignment -name SYSTEMVERILOG_FILE MacPlus.sv
diff --git a/rtl/addrController_top.v b/rtl/addrController_top.v
index 5abdf34..421718a 100644
--- a/rtl/addrController_top.v
+++ b/rtl/addrController_top.v
@@ -1,216 +1,218 @@
-module addrController_top(
-	// clocks:
-	input clk,
-	output clk8,						// 8.125 MHz CPU clock
-	output clk8_en_p,
-	output clk8_en_n,
-	output clk16_en_p,
-	output clk16_en_n,
-
-	// system config:
-	input turbo,               // 0 = normal, 1 = faster
-	input [1:0] configROMSize,  // 0 = 64K ROM, 1 = 128K ROM, 2 = 256K ROM
-	input [1:0] configRAMSize,	// 0 = 128K, 1 = 512K, 2 = 1MB, 3 = 4MB RAM
-
-	// 68000 CPU memory interface:
-	input [23:0] cpuAddr,
-	input _cpuUDS,
-	input _cpuLDS,
-	input _cpuRW,	
-	input _cpuAS,
-	
-	// RAM/ROM:
-	output [21:0] memoryAddr,
-	output _memoryUDS,
-	output _memoryLDS,	
-	output _romOE,
-	output _ramOE,	
-	output _ramWE,	
-	output videoBusControl,
-	output dioBusControl,
-	output cpuBusControl,
-	output memoryLatch,
-	
-	// peripherals:
-	output selectSCSI,
-	output selectSCC,
-	output selectIWM,
-	output selectVIA,
-	output selectRAM,
-	output selectROM,
-	output selectSEOverlay,
-	
-	// video:
-	output hsync,
-	output vsync,
-	output _hblank,
-	output _vblank,
-	output loadPixels,
-	input  vid_alt,
-		
-	input  snd_alt,
-	output loadSound,
-		
-	// misc
-	input memoryOverlayOn,
-	
-	// interface to read dsk image from ram
-	input [21:0] dskReadAddrInt,
-	output dskReadAckInt,
-	input [21:0] dskReadAddrExt,
-	output dskReadAckExt
-);
-
-	// -------------- audio engine (may be moved into seperate module) ---------------
-	assign loadSound = sndReadAck;
-
-	localparam SIZE = 20'd135408;  // 168*806 clk8 events per frame
-	localparam STEP = 20'd5920;    // one step every 16*370 clk8 events
-	
-	reg [21:0] audioAddr; 
-	reg [19:0] snd_div;
-	
-	reg sndReadAckD;
-	always @(posedge clk)
-		if (clk8_en_n) sndReadAckD <= sndReadAck;
-	
-	reg vblankD, vblankD2;
-	always @(posedge clk) begin
-		if(clk8_en_p && sndReadAckD) begin
-			vblankD <= _vblank;
-			vblankD2 <= vblankD;
-		
-			// falling adge of _vblank = begin of vblank phase
-			if(vblankD2 && !vblankD) begin
-				audioAddr <= snd_alt?22'h3FA100:22'h3FFD00;
-				snd_div <= 20'd0;
-			end else begin
-				if(snd_div >= SIZE-1) begin
-					snd_div <= snd_div - SIZE + STEP;
-					audioAddr <= audioAddr + 22'd2;
-				end else
-					snd_div <= snd_div + STEP;
-			end
-		end
-	end
-
-	assign dioBusControl = extraBusControl;
-
-	// interleaved RAM access for CPU and video
-	reg [1:0] busCycle;
-	reg [1:0] busPhase;
-	reg [1:0] extra_slot_count;
-
-	always @(posedge clk) begin
-		busPhase <= busPhase + 1'd1;
-		if (busPhase == 2'b11)
-			busCycle <= busCycle + 2'd1;
-	end
-	assign memoryLatch = busPhase == 2'd3;
-	assign clk8 = !busPhase[1];
-	assign clk8_en_p = busPhase == 2'b11;
-	assign clk8_en_n = busPhase == 2'b01;
-	assign clk16_en_p = !busPhase[0];
-	assign clk16_en_n = busPhase[0];
-
-	reg extra_slot_advance;
-	always @(posedge clk)
-		if (clk8_en_n) extra_slot_advance <= (busCycle == 2'b11);
-
-	// allocate memory slots in the extra cycle
-	always @(posedge clk) begin
-		if(clk8_en_p && extra_slot_advance) begin
-			extra_slot_count <= extra_slot_count + 2'd1;
-		end
-	end
-
-	// video controls memory bus during the first clock of the four-clock cycle
-	assign videoBusControl = (busCycle == 2'b00);
-	// cpu controls memory bus during the second and fourth clock of the four-clock cycle
-	assign cpuBusControl = (busCycle == 2'b01) || (busCycle == 2'b11);
-	// IWM/audio gets 3rd cycle
-	wire extraBusControl = (busCycle == 2'b10);
-
-	// interconnects
-	wire [21:0] videoAddr;
-	
-	// RAM/ROM control signals
-	wire videoControlActive = _hblank;
-
-	assign _romOE = ~(cpuBusControl && selectROM && _cpuRW);
-	
-	wire extraRamRead = sndReadAck;
-	assign _ramOE = ~((videoBusControl && videoControlActive) || (extraRamRead) ||
-						(cpuBusControl && selectRAM && _cpuRW));
-	assign _ramWE = ~(cpuBusControl && selectRAM && !_cpuRW);
-	
-	assign _memoryUDS = cpuBusControl ? _cpuUDS : 1'b0;
-	assign _memoryLDS = cpuBusControl ? _cpuLDS : 1'b0;
-	wire [21:0] addrMux = sndReadAck ? audioAddr : videoBusControl ? videoAddr : cpuAddr[21:0];
-	wire [21:0] macAddr;
-	assign macAddr[15:0] = addrMux[15:0];
-
-	// video and sound always addresses ram
-	wire ram_access = (cpuBusControl && selectRAM) || videoBusControl || sndReadAck;
-	wire rom_access = (cpuBusControl && selectROM);
-	
-	// simulate smaller RAM/ROM sizes
-	assign macAddr[16] = rom_access && configROMSize == 2'b00 ? 1'b0 :     // force A16 to 0 for 64K ROM access
-									addrMux[16]; 
-	assign macAddr[17] = ram_access && configRAMSize == 2'b00 ? 1'b0 :   // force A17 to 0 for 128K RAM access
-									rom_access && configROMSize == 2'b01 ? 1'b0 :  // force A17 to 0 for 128K ROM access
-									rom_access && configROMSize == 2'b00 ? 1'b1 :  // force A17 to 1 for 64K ROM access (64K ROM image is at $20000)
-									addrMux[17]; 
-	assign macAddr[18] = ram_access && configRAMSize == 2'b00 ? 1'b0 :   // force A18 to 0 for 128K RAM access
-	                     rom_access && configROMSize != 2'b11 ? 1'b0 : // force A18 to 0 for 64K/128K/256K ROM access
-									addrMux[18]; 
-	assign macAddr[19] = ram_access && configRAMSize[1] == 1'b0 ? 1'b0 : // force A19 to 0 for 128K or 512K RAM access
-									rom_access ? 1'b0 : 								   // force A19 to 0 for ROM access
-									addrMux[19]; 
-	assign macAddr[20] = ram_access && configRAMSize != 2'b11 ? 1'b0 :   // force A20 to 0 for all but 4MB RAM access
-									rom_access ? 1'b0 : 								   // force A20 to 0 for ROM access
-									addrMux[20]; 
-	assign macAddr[21] = ram_access && configRAMSize != 2'b11 ? 1'b0 :   // force A21 to 0 for all but 4MB RAM access
-									rom_access ? 1'b0 : 								   // force A21 to 0 for ROM access
-									addrMux[21]; 
-	
-			
-	// floppy emulation gets extra slots 0 and 1
-	assign dskReadAckInt = (extraBusControl == 1'b1) && (extra_slot_count == 0);
-	assign dskReadAckExt = (extraBusControl == 1'b1) && (extra_slot_count == 1);
-	// audio gets extra slot 2
-	wire sndReadAck    = (extraBusControl == 1'b1) && (extra_slot_count == 2);
-
-	assign memoryAddr = 
-		dskReadAckInt ? dskReadAddrInt + 22'h100000:   // first dsk image at 1MB
-		dskReadAckExt ? dskReadAddrExt + 22'h200000:   // second dsk image at 2MB
-		macAddr;
-
-	// address decoding
-	addrDecoder ad(
-		.configROMSize(configROMSize),
-		.address(cpuAddr),
-		._cpuAS(_cpuAS),
-		.memoryOverlayOn(memoryOverlayOn),
-		.selectRAM(selectRAM),
-		.selectROM(selectROM),
-		.selectSCSI(selectSCSI),
-		.selectSCC(selectSCC),
-		.selectIWM(selectIWM),
-		.selectVIA(selectVIA),
-		.selectSEOverlay(selectSEOverlay));
-
-	// video
-	videoTimer vt(
-		.clk(clk),
-		.clk_en(clk8_en_p),
-		.busCycle(busCycle), 
-		.vid_alt(vid_alt),
-		.videoAddr(videoAddr), 
-		.hsync(hsync), 
-		.vsync(vsync), 
-		._hblank(_hblank),
-		._vblank(_vblank), 
-		.loadPixels(loadPixels));
-		
-endmodule
+module addrController_top(
+	// clocks:
+	input clk,
+	output clk8,						// 8.125 MHz CPU clock
+	output clk8_en_p,
+	output clk8_en_n,
+	output clk16_en_p,
+	output clk16_en_n,
+
+	// system config:
+	input turbo,               // 0 = normal, 1 = faster
+	input [1:0] configROMSize,  // 0 = 64K ROM, 1 = 128K ROM, 2 = 256K ROM
+	input [1:0] configRAMSize,	// 0 = 128K, 1 = 512K, 2 = 1MB, 3 = 4MB RAM
+
+	// 68000 CPU memory interface:
+	input [31:0] cpuAddr,
+	input _cpuUDS,
+	input _cpuLDS,
+	input _cpuRW,
+	input _cpuAS,
+
+	// RAM/ROM:
+	output [21:0] memoryAddr,
+	output _memoryUDS,
+	output _memoryLDS,
+	output _romOE,
+	output _ramOE,
+	output _ramWE,
+	output videoBusControl,
+	output dioBusControl,
+	output cpuBusControl,
+	output memoryLatch,
+
+	// peripherals:
+	output selectSCSI,
+	output selectSCC,
+	output selectIWM,
+	output selectVIA,
+	output selectRAM,
+	output selectROM,
+	output selectSEOverlay,
+	output selectNuBus,
+
+	// video:
+	output hsync,
+	output vsync,
+	output _hblank,
+	output _vblank,
+	output loadPixels,
+	input  vid_alt,
+
+	input  snd_alt,
+	output loadSound,
+
+	// misc
+	input memoryOverlayOn,
+
+	// interface to read dsk image from ram
+	input [21:0] dskReadAddrInt,
+	output dskReadAckInt,
+	input [21:0] dskReadAddrExt,
+	output dskReadAckExt
+);
+
+	// -------------- audio engine (may be moved into seperate module) ---------------
+	assign loadSound = sndReadAck;
+
+	localparam SIZE = 20'd135408;  // 168*806 clk8 events per frame
+	localparam STEP = 20'd5920;    // one step every 16*370 clk8 events
+
+	reg [21:0] audioAddr;
+	reg [19:0] snd_div;
+
+	reg sndReadAckD;
+	always @(posedge clk)
+		if (clk8_en_n) sndReadAckD <= sndReadAck;
+
+	reg vblankD, vblankD2;
+	always @(posedge clk) begin
+		if(clk8_en_p && sndReadAckD) begin
+			vblankD <= _vblank;
+			vblankD2 <= vblankD;
+
+			// falling adge of _vblank = begin of vblank phase
+			if(vblankD2 && !vblankD) begin
+				audioAddr <= snd_alt?22'h3FA100:22'h3FFD00;
+				snd_div <= 20'd0;
+			end else begin
+				if(snd_div >= SIZE-1) begin
+					snd_div <= snd_div - SIZE + STEP;
+					audioAddr <= audioAddr + 22'd2;
+				end else
+					snd_div <= snd_div + STEP;
+			end
+		end
+	end
+
+	assign dioBusControl = extraBusControl;
+
+	// interleaved RAM access for CPU and video
+	reg [1:0] busCycle;
+	reg [1:0] busPhase;
+	reg [1:0] extra_slot_count;
+
+	always @(posedge clk) begin
+		busPhase <= busPhase + 1'd1;
+		if (busPhase == 2'b11)
+			busCycle <= busCycle + 2'd1;
+	end
+	assign memoryLatch = busPhase == 2'd3;
+	assign clk8 = !busPhase[1];
+	assign clk8_en_p = busPhase == 2'b11;
+	assign clk8_en_n = busPhase == 2'b01;
+	assign clk16_en_p = !busPhase[0];
+	assign clk16_en_n = busPhase[0];
+
+	reg extra_slot_advance;
+	always @(posedge clk)
+		if (clk8_en_n) extra_slot_advance <= (busCycle == 2'b11);
+
+	// allocate memory slots in the extra cycle
+	always @(posedge clk) begin
+		if(clk8_en_p && extra_slot_advance) begin
+			extra_slot_count <= extra_slot_count + 2'd1;
+		end
+	end
+
+	// video controls memory bus during the first clock of the four-clock cycle
+	assign videoBusControl = (busCycle == 2'b00);
+	// cpu controls memory bus during the second and fourth clock of the four-clock cycle
+	assign cpuBusControl = (busCycle == 2'b01) || (busCycle == 2'b11);
+	// IWM/audio gets 3rd cycle
+	wire extraBusControl = (busCycle == 2'b10);
+
+	// interconnects
+	wire [21:0] videoAddr;
+
+	// RAM/ROM control signals
+	wire videoControlActive = _hblank;
+
+	assign _romOE = ~(cpuBusControl && selectROM && _cpuRW);
+
+	wire extraRamRead = sndReadAck;
+	assign _ramOE = ~((videoBusControl && videoControlActive) || (extraRamRead) ||
+						(cpuBusControl && selectRAM && _cpuRW));
+	assign _ramWE = ~(cpuBusControl && selectRAM && !_cpuRW);
+
+	assign _memoryUDS = cpuBusControl ? _cpuUDS : 1'b0;
+	assign _memoryLDS = cpuBusControl ? _cpuLDS : 1'b0;
+	wire [21:0] addrMux = sndReadAck ? audioAddr : videoBusControl ? videoAddr : cpuAddr[21:0];
+	wire [21:0] macAddr;
+	assign macAddr[15:0] = addrMux[15:0];
+
+	// video and sound always addresses ram
+	wire ram_access = (cpuBusControl && selectRAM) || videoBusControl || sndReadAck;
+	wire rom_access = (cpuBusControl && selectROM);
+
+	// simulate smaller RAM/ROM sizes
+	assign macAddr[16] = rom_access && configROMSize == 2'b00 ? 1'b0 :     // force A16 to 0 for 64K ROM access
+									addrMux[16];
+	assign macAddr[17] = ram_access && configRAMSize == 2'b00 ? 1'b0 :   // force A17 to 0 for 128K RAM access
+									rom_access && configROMSize == 2'b01 ? 1'b0 :  // force A17 to 0 for 128K ROM access
+									rom_access && configROMSize == 2'b00 ? 1'b1 :  // force A17 to 1 for 64K ROM access (64K ROM image is at $20000)
+									addrMux[17];
+	assign macAddr[18] = ram_access && configRAMSize == 2'b00 ? 1'b0 :   // force A18 to 0 for 128K RAM access
+	                     rom_access && configROMSize != 2'b11 ? 1'b0 : // force A18 to 0 for 64K/128K/256K ROM access
+									addrMux[18];
+	assign macAddr[19] = ram_access && configRAMSize[1] == 1'b0 ? 1'b0 : // force A19 to 0 for 128K or 512K RAM access
+									rom_access ? 1'b0 : 								   // force A19 to 0 for ROM access
+									addrMux[19];
+	assign macAddr[20] = ram_access && configRAMSize != 2'b11 ? 1'b0 :   // force A20 to 0 for all but 4MB RAM access
+									rom_access ? 1'b0 : 								   // force A20 to 0 for ROM access
+									addrMux[20];
+	assign macAddr[21] = ram_access && configRAMSize != 2'b11 ? 1'b0 :   // force A21 to 0 for all but 4MB RAM access
+									rom_access ? 1'b0 : 								   // force A21 to 0 for ROM access
+									addrMux[21];
+
+
+	// floppy emulation gets extra slots 0 and 1
+	assign dskReadAckInt = (extraBusControl == 1'b1) && (extra_slot_count == 0);
+	assign dskReadAckExt = (extraBusControl == 1'b1) && (extra_slot_count == 1);
+	// audio gets extra slot 2
+	wire sndReadAck    = (extraBusControl == 1'b1) && (extra_slot_count == 2);
+
+	assign memoryAddr =
+		dskReadAckInt ? dskReadAddrInt + 22'h100000:   // first dsk image at 1MB
+		dskReadAckExt ? dskReadAddrExt + 22'h200000:   // second dsk image at 2MB
+		macAddr;
+
+	// address decoding
+	addrDecoder ad(
+		.configROMSize(configROMSize),
+		.address(cpuAddr),
+		._cpuAS(_cpuAS),
+		.memoryOverlayOn(memoryOverlayOn),
+		.selectRAM(selectRAM),
+		.selectROM(selectROM),
+		.selectSCSI(selectSCSI),
+		.selectSCC(selectSCC),
+		.selectIWM(selectIWM),
+		.selectVIA(selectVIA),
+		.selectSEOverlay(selectSEOverlay),
+		.selectNuBus(selectNuBus));
+
+	// video
+	videoTimer vt(
+		.clk(clk),
+		.clk_en(clk8_en_p),
+		.busCycle(busCycle),
+		.vid_alt(vid_alt),
+		.videoAddr(videoAddr),
+		.hsync(hsync),
+		.vsync(vsync),
+		._hblank(_hblank),
+		._vblank(_vblank),
+		.loadPixels(loadPixels));
+
+endmodule
diff --git a/rtl/addrDecoder.v b/rtl/addrDecoder.v
index fac3fbd..f3425c5 100644
--- a/rtl/addrDecoder.v
+++ b/rtl/addrDecoder.v
@@ -1,34 +1,34 @@
-/* 
-	($000000 - $03FFFF) RAM  4MB, or Overlay ROM 4MB
+/*
+	($000000 - $03FFFF) RAM  4MB, or Overlay ROM 4MB
 	
 	($400000 - $4FFFFF) ROM 1MB
-		64K Mac 128K/512K ROM is $400000 - $40FFFF
-		128K Mac 512Ke/Plus ROM is $400000 - $41FFFF
-		If ROM is mirrored when A17 is 1, then SCSI is assumed to be unavailable
-	
-	($580000 - $580FFF) SCSI (Mac Plus only, not implemented here)
-	
-	($600000 - $7FFFFF) Overlay RAM 2MB
-	
-	($9FFFF8 - $BFFFFF) SCC
-		The SCC is on the upper byte of the data bus, so you must use only even-addressed byte reads.
-		When writing, you must use only odd-addressed byte writes (the MC68000 puts your data on both bytes of the bus, so it works correctly). 
-		A byte read of an odd SCC read address tries to reset the entire SCC. 
-		A word access to any SCC address will shift the phase of the computer's high-frequency timing by 128 ns.
-
-		($9FFFF8) SCC read channel B control
-		($9FFFFA) SCC read channel A control
-		($9FFFFC) SCC read channel B data in/out
-		($9FFFFE) SCC read channel A data in/out
-		
-		($BFFFF9) SCC write channel B control
-		($BFFFFB) SCC write channel A control
-		($BFFFFD) SCC write channel B data in/out
+		64K Mac 128K/512K ROM is $400000 - $40FFFF
+		128K Mac 512Ke/Plus ROM is $400000 - $41FFFF
+		If ROM is mirrored when A17 is 1, then SCSI is assumed to be unavailable
+
+	($580000 - $580FFF) SCSI (Mac Plus only, not implemented here)
+
+	($600000 - $7FFFFF) Overlay RAM 2MB
+
+	($9FFFF8 - $BFFFFF) SCC
+		The SCC is on the upper byte of the data bus, so you must use only even-addressed byte reads.
+		When writing, you must use only odd-addressed byte writes (the MC68000 puts your data on both bytes of the bus, so it works correctly).
+		A byte read of an odd SCC read address tries to reset the entire SCC.
+		A word access to any SCC address will shift the phase of the computer's high-frequency timing by 128 ns.
+
+		($9FFFF8) SCC read channel B control
+		($9FFFFA) SCC read channel A control
+		($9FFFFC) SCC read channel B data in/out
+		($9FFFFE) SCC read channel A data in/out
+
+		($BFFFF9) SCC write channel B control
+		($BFFFFB) SCC write channel A control
+		($BFFFFD) SCC write channel B data in/out
 		($BFFFFF) SCC write channel A data in/out
 
-	($DFE1FF - $DFFFFF) IWM
+	($DFE1FF - $DFFFFF) IWM
 		The IWM is on the lower byte of the data bus, so use odd-addressed byte accesses only. 
-		The 16 IWM registers are {8'hDF, 8'b111xxxx1, 8'hFF}:
+		The 16 IWM registers are {8'hDF, 8'b111xxxx1, 8'hFF}:
 			0	$0		ph0L		CA0 off (0)
 			1	$200	ph0H		CA0 on (1)
 			2	$400	ph1L		CA1 off (0)
@@ -44,12 +44,12 @@
 			12	$1800	q6L		Q6 off
 			13	$1A00	q6H		Q6 on
 			14	$1C00	q7L		Q7 off, read register
-			15	$1E00	q7H		Q7 on, write register
+			15	$1E00	q7H		Q7 on, write register
 		
-	($EFE1FE - $EFFFFE) VIA 
-		The VIA is on the upper byte of the data bus, so use even-addressed byte accesses only.
-		The 16 VIA registers are {8'hEF, 8'b111xxxx1, 8'hFE}:
-			0	$0		vBufB		register B
+	($EFE1FE - $EFFFFE) VIA
+		The VIA is on the upper byte of the data bus, so use even-addressed byte accesses only.
+		The 16 VIA registers are {8'hEF, 8'b111xxxx1, 8'hFE}:
+			0	$0		vBufB		register B
 			1	$200	?????		not used?
 			2	$400	vDirB		register B direction register
 			3	$600	vDirA		register A direction register
@@ -68,78 +68,100 @@
 
 	($F00000 - $F00005) memory phase read test
 
-	($F80000 - $FFFFEF) space for test software
-	
-	($FFFFF0 - $FFFFFF) interrupt vectors
-	
-	Note: This can all be decoded using only the highest 4 address bits, if SCSI, phase read test, and test software are not used.
-	7 other address bits are used by peripherals to determine which register to access:
-		A12-A9 - IWM and VIA
-		A2-A0 - SCC
-	
-*/
-
-module addrDecoder(
-	input [1:0] configROMSize,
-	input [23:0] address,
-	input _cpuAS,
-	input memoryOverlayOn,
-	output reg selectRAM,
-	output reg selectROM,
-	output reg selectSCSI,
-	output reg selectSCC,
-	output reg selectIWM,
-	output reg selectVIA,
-	output reg selectSEOverlay
-);
-
-	always @(*) begin
-		selectRAM = 0;
-		selectROM = 0;
-		selectSCSI = 0;
-		selectSCC = 0;
-		selectIWM = 0;
-		selectVIA = 0;
-		selectSEOverlay = 0;
-		
-		casez (address[23:20])
-			4'b00??: begin //00 0000 - 3F FFFF
-				if (memoryOverlayOn == 0)
-					selectRAM = !_cpuAS;
-				else begin
-					if (address[23:20] == 0) begin
-						// Mac Plus: repeated images of overlay ROM only extend to $0F0000
-						// Mac 512K: more repeated ROM images at $020000-$02FFFF
-						// Mac SE:   overlay ROM at $00 0000 - $0F FFFF
-						selectROM = !_cpuAS;
-					end
-				end
-			end
-			4'b0100: begin //40 0000 - 4F FFFF
-				if(configROMSize[1] || address[17] == 1'b0)   // <- this detects SCSI (on Plus)!!!
-					selectROM = !_cpuAS;
-				selectSEOverlay = !_cpuAS;
-			end
-			4'b0101: begin //50 000 - 5F FFFF
-				if (address[19]) // 58 000 - 5F FFFF
-					selectSCSI = !_cpuAS;
-				selectSEOverlay = !_cpuAS;
-			end
-			4'b0110: 
-				if (memoryOverlayOn)
-					selectRAM = !_cpuAS;
-			4'b10?1:
-				selectSCC = !_cpuAS;
-			4'b1100: // C0 000 - CF FFF
-				if (!configROMSize[1])
-					selectIWM = !_cpuAS;
-			4'b1101:
-				selectIWM = !_cpuAS;
-			4'b1110:
-				if (address[19]) // E8 000 - EF FFF
-					selectVIA = !_cpuAS;
-			default:
-				; // select nothing
-		endcase
-	end
-endmodule
+	($F80000 - $FFFFEF) space for test software
+
+	($FFFFF0 - $FFFFFF) interrupt vectors
+
+	Note: This can all be decoded using only the highest 4 address bits, if SCSI, phase read test, and test software are not used.
+	7 other address bits are used by peripherals to determine which register to access:
+		A12-A9 - IWM and VIA
+		A2-A0 - SCC
+
+*/
+
+module addrDecoder(
+	input [1:0] configROMSize,
+	input [31:0] address,
+	input _cpuAS,
+	input memoryOverlayOn,
+	output reg selectRAM,
+	output reg selectROM,
+	output reg selectSCSI,
+	output reg selectSCC,
+	output reg selectIWM,
+	output reg selectVIA,
+	output reg selectSEOverlay,
+	output reg selectNuBus
+);
+
+	always @(*) begin
+		selectRAM = 0;
+		selectROM = 0;
+		selectSCSI = 0;
+		selectSCC = 0;
+		selectIWM = 0;
+		selectVIA = 0;
+		selectSEOverlay = 0;
+		selectNuBus = 0;
+
+		// 24-bit addressing mode check or assumption?
+		// For now, assuming if address[31:24] != 0, it's 32-bit space.
+		// Mac II ROM maps slot space at $F9000000+
+
+		if (address[31:24] != 8'h00 && address[31:24] != 8'hFF) begin
+			// 32-bit addressing (NuBus)
+			// Standard Slots: $9000 0000 - $EFFF FFFF (Slots 9-E)
+			// Super Slots:    $F900 0000 - $FEFF FFFF (Slots 9-E)
+			if ((address[31:28] >= 4'h9 && address[31:28] <= 4'hE) ||
+			    (address[31:24] >= 8'hF9 && address[31:24] <= 8'hFE)) begin
+				selectNuBus = !_cpuAS;
+			end
+
+			// Mac II ROM is at $4080 0000? Or just normal ROM space?
+			// The Mac II likely mirrors ROM at 0 during boot if overlay is on.
+		end
+
+		// 24-bit space (or mapped 24-bit in 32-bit mode, usually 00xxxxxx)
+		if (address[31:24] == 8'h00) begin
+			casez (address[23:20])
+				4'b00??: begin //00 0000 - 3F FFFF
+					if (memoryOverlayOn == 0)
+						selectRAM = !_cpuAS;
+					else begin
+						if (address[23:20] == 0) begin
+							// Mac Plus: repeated images of overlay ROM only extend to $0F0000
+							// Mac 512K: more repeated ROM images at $020000-$02FFFF
+							// Mac SE:   overlay ROM at $00 0000 - $0F FFFF
+							selectROM = !_cpuAS;
+						end
+					end
+				end
+				4'b0100: begin //40 0000 - 4F FFFF
+					if(configROMSize[1] || address[17] == 1'b0)   // <- this detects SCSI (on Plus)!!!
+						selectROM = !_cpuAS;
+					selectSEOverlay = !_cpuAS;
+				end
+				4'b0101: begin //50 000 - 5F FFFF
+					if (address[19]) // 58 000 - 5F FFFF
+						selectSCSI = !_cpuAS;
+					selectSEOverlay = !_cpuAS;
+				end
+				4'b0110:
+					if (memoryOverlayOn)
+						selectRAM = !_cpuAS;
+				4'b10?1:
+					selectSCC = !_cpuAS;
+				4'b1100: // C0 000 - CF FFF
+					if (!configROMSize[1])
+						selectIWM = !_cpuAS;
+				4'b1101:
+					selectIWM = !_cpuAS;
+				4'b1110:
+					if (address[19]) // E8 000 - EF FFF
+						selectVIA = !_cpuAS;
+				default:
+					; // select nothing
+			endcase
+		end
+	end
+endmodule
diff --git a/rtl/dataController_top.sv b/rtl/dataController_top.sv
index 651695d..347a771 100644
--- a/rtl/dataController_top.sv
+++ b/rtl/dataController_top.sv
@@ -1,524 +1,528 @@
-module dataController_top(
-	// clocks:
-	input clk32,					// 32.5 MHz pixel clock
-	input clk8_en_p,
-	input clk8_en_n,
-	input E_rising,
-	input E_falling,
-	
-	// system control:
-	input machineType, // 0 - Mac Plus, 1 - Mac SE
-	input _systemReset,
-
-	// 68000 CPU control:
-	output _cpuReset,
-	output [2:0] _cpuIPL,
-
-	// 68000 CPU memory interface:
-	input [15:0] cpuDataIn,
-	input [3:0] cpuAddrRegHi, // A12-A9
-	input [2:0] cpuAddrRegMid, // A6-A4
-	input [1:0] cpuAddrRegLo, // A2-A1
-	input _cpuUDS,
-	input _cpuLDS,	
-	input _cpuRW,
-	output [15:0] cpuDataOut,
-	
-	// peripherals:
-	input selectSCSI,
-	input selectSCC,
-	input selectIWM,
-	input selectVIA,
-	input selectSEOverlay,
-	input _cpuVMA,
-	
-	// RAM/ROM:
-	input videoBusControl,	
-	input cpuBusControl,	
-	input [15:0] memoryDataIn,
-	output [15:0] memoryDataOut,
-	input memoryLatch,
-	
-	// keyboard:
-	input [10:0] ps2_key,
-	output capslock, 
-	 
-	// mouse:
-	input [24:0] ps2_mouse,
-	
-	// serial:
-	input serialIn, 
-	output serialOut,	
-	input serialCTS,
-	output serialRTS,
-
-	// RTC
-	input [32:0] timestamp,
-
-	// video:
-	output pixelOut,	
-	input _hblank,
-	input _vblank,
-	input loadPixels,
-	output vid_alt,
-
-	// audio
-	output [10:0] audioOut,  // 8 bit audio + 3 bit volume
-	output snd_alt,
-	input loadSound,
-	
-	// misc
-	output memoryOverlayOn,
-	input [1:0] insertDisk,
-	input [1:0] diskSides,
-	output [1:0] diskEject,
-	output [1:0] diskMotor,
-	output [1:0] diskAct,
-
-	output [21:0] dskReadAddrInt,
-	input dskReadAckInt,
-	output [21:0] dskReadAddrExt,
-	input dskReadAckExt,
-
-	// connections to io controller
-	input   [SCSI_DEVS-1:0] img_mounted,
-	input            [31:0] img_size,
-	output           [31:0] io_lba[SCSI_DEVS],
-	output  [SCSI_DEVS-1:0] io_rd,
-	output  [SCSI_DEVS-1:0] io_wr,
-	input   [SCSI_DEVS-1:0] io_ack,
-	input             [7:0] sd_buff_addr,
-	input            [15:0] sd_buff_dout,
-	output           [15:0] sd_buff_din[SCSI_DEVS],
-	input                   sd_buff_wr
-);
-	
-	parameter SCSI_DEVS = 2;
-	
-	// add binary volume levels according to volume setting
-	assign audioOut = 
-		(snd_vol[0]?audio_x1:11'd0) +
-		(snd_vol[1]?audio_x2:11'd0) +
-		(snd_vol[2]?audio_x4:11'd0);
-
-	// three binary volume levels *1, *2 and *4, sign expanded
-	wire [10:0] audio_x1 = { {3{audio_latch[7]}}, audio_latch };
-	wire [10:0] audio_x2 = { {2{audio_latch[7]}}, audio_latch, 1'b0 };
-	wire [10:0] audio_x4 = {    audio_latch[7]  , audio_latch, 2'b00};
-	
-	reg loadSoundD;
-	always @(posedge clk32)
-		if (clk8_en_n) loadSoundD <= loadSound;
-
-	// read audio data and convert to signed for further volume adjustment
-	reg [7:0] audio_latch;
-	always @(posedge clk32) begin
-		if(clk8_en_p && loadSoundD) begin
-			if(snd_ena) audio_latch <= 8'h7f; // when disabled, drive output high
-			else  	 	audio_latch <= memoryDataIn[15:8] - 8'd128;
-		end
-	end
-	
-	// CPU reset generation
-	// For initial CPU reset, RESET and HALT must be asserted for at least 100ms = 800,000 clocks of clk8
-	reg [19:0] resetDelay; // 20 bits = 1 million
-	wire isResetting = resetDelay != 0;
-
-	initial begin
-		// force a reset when the FPGA configuration is completed
-		resetDelay <= 20'hFFFFF;
-	end
-	
-	always @(posedge clk32 or negedge _systemReset) begin
-		if (_systemReset == 1'b0) begin
-			resetDelay <= 20'hFFFFF;
-		end
-		else if (clk8_en_p && isResetting) begin
-			resetDelay <= resetDelay - 1'b1;
-		end
-	end
-	assign _cpuReset = isResetting ? 1'b0 : 1'b1;
-	
-	// interconnects
-	wire SEL;
-	wire _viaIrq, _sccIrq, sccWReq;
-	wire [15:0] viaDataOut;
-	wire [15:0] iwmDataOut;
-	wire [7:0] sccDataOut;
-	wire [7:0] scsiDataOut;
-	wire mouseX1, mouseX2, mouseY1, mouseY2, mouseButton;
-	
-	// interrupt control
-	assign _cpuIPL = 
-		!_viaIrq?3'b110:
-		!_sccIrq?3'b101:
-		3'b111;
-		
-
-	reg [15:0] cpu_data;
-	always @(posedge clk32) if (cpuBusControl && memoryLatch) cpu_data <= memoryDataIn;
-
-	// CPU-side data output mux
-	assign cpuDataOut = selectIWM ? iwmDataOut :
-							  selectVIA ? viaDataOut :
-							  selectSCC ? { sccDataOut, 8'hEF } :
-							  selectSCSI ? { scsiDataOut, 8'hEF } :
-							  (cpuBusControl && memoryLatch) ? memoryDataIn : cpu_data;
-	
-	// Memory-side
-	assign memoryDataOut = cpuDataIn;
-
-	// SCSI
-	ncr5380 #(SCSI_DEVS) scsi(
-		.clk(clk32),
-		.reset(!_cpuReset),
-		.bus_cs(selectSCSI),
-		.bus_rs(cpuAddrRegMid),
-		.ior(!_cpuUDS),
-		.iow(!_cpuLDS),
-		.dack(cpuAddrRegHi[0]),   // A9
-		.wdata(cpuDataIn[15:8]),
-		.rdata(scsiDataOut),
-
-		// connections to io controller
-		.img_mounted( img_mounted ),
-		.img_size( img_size ),
-		.io_lba ( io_lba ),
-		.io_rd ( io_rd ),
-		.io_wr ( io_wr ),
-		.io_ack ( io_ack ),
-
-		.sd_buff_addr(sd_buff_addr),
-		.sd_buff_dout(sd_buff_dout),
-		.sd_buff_din(sd_buff_din),
-		.sd_buff_wr(sd_buff_wr)
-	);
-
-	// count vblanks, and set 1 second interrupt after 60 vblanks
-	reg [5:0] vblankCount;
-	reg _lastVblank;
-	always @(posedge clk32) begin
-		if (clk8_en_n) begin
-			_lastVblank <= _vblank;
-			if (_vblank == 1'b0 && _lastVblank == 1'b1) begin
-				if (vblankCount != 59) begin
-					vblankCount <= vblankCount + 1'b1;
-				end
-				else begin
-					vblankCount <= 6'h0;
-				end
-			end
-		end
-	end
-	wire onesec = vblankCount == 59;
-
-	// Mac SE ROM overlay switch
-	reg  SEOverlay;
-	always @(posedge clk32) begin
-		if (!_cpuReset)
-			SEOverlay <= 1;
-		else if (selectSEOverlay)
-			SEOverlay <= 0;
-	end
-
-	// VIA
-	wire [2:0] snd_vol;
-	wire snd_ena;
-	wire driveSel; // internal drive select, 0 - upper, 1 - lower
-
-	wire [7:0] via_pa_i, via_pa_o, via_pa_oe;
-	wire [7:0] via_pb_i, via_pb_o, via_pb_oe;
-	wire viaIrq;
-
-	assign _viaIrq = ~viaIrq;
-
-	//port A
-	assign via_pa_i = {sccWReq, ~via_pa_oe[6:0] | via_pa_o[6:0]};
-	assign snd_vol = ~via_pa_oe[2:0] | via_pa_o[2:0];
-	assign snd_alt = machineType ? 1'b0 : ~(~via_pa_oe[3] | via_pa_o[3]);
-	assign driveSel = machineType ? ~via_pa_oe[4] | via_pa_o[4] : 1'b1;
-	assign memoryOverlayOn = machineType ? SEOverlay : ~via_pa_oe[4] | via_pa_o[4];
-	assign SEL = ~via_pa_oe[5] | via_pa_o[5];
-	assign vid_alt = ~via_pa_oe[6] | via_pa_o[6];
-
-	//port B
-	assign via_pb_i = {1'b1, {3{machineType}} | {_hblank, mouseY2, mouseX2}, machineType ? _ADBint : mouseButton, 2'b11, rtcdat_o};
-	assign snd_ena = ~via_pb_oe[7] | via_pb_o[7];
-
-	assign viaDataOut[7:0] = 8'hEF;
-
-	via6522 via(
-		.clock      (clk32),
-		.rising     (E_rising),
-		.falling    (E_falling),
-		.reset      (!_cpuReset),
-
-		.addr       (cpuAddrRegHi),
-		.wen        (selectVIA && !_cpuVMA && !_cpuRW),
-		.ren        (selectVIA && !_cpuVMA &&  _cpuRW),
-		.data_in    (cpuDataIn[15:8]),
-		.data_out   (viaDataOut[15:8]),
-
-		.phi2_ref   (),
-
-		//-- pio --
-		.port_a_o   (via_pa_o),
-		.port_a_t   (via_pa_oe),
-		.port_a_i   (via_pa_i),
-
-		.port_b_o   (via_pb_o),
-		.port_b_t   (via_pb_oe),
-		.port_b_i   (via_pb_i),
-
-		//-- handshake pins
-		.ca1_i      (_vblank),
-		.ca2_i      (onesec),
-
-		.cb1_i      (kbdclk),
-		.cb2_i      (cb2_i),
-		.cb2_o      (cb2_o),
-		.cb2_t      (cb2_t),
-
-		.irq        (viaIrq)
-	);
-
-	wire _rtccs   = ~via_pb_oe[2] | via_pb_o[2];
-	wire rtcck    = ~via_pb_oe[1] | via_pb_o[1];
-	wire rtcdat_i = ~via_pb_oe[0] | via_pb_o[0];
-	wire rtcdat_o;
-
-	rtc pram (
-		.clk        (clk32),
-		.reset      (!_cpuReset),
-		.timestamp  (timestamp),
-		._cs        (_rtccs),
-		.ck         (rtcck),
-		.dat_i      (rtcdat_i),
-		.dat_o      (rtcdat_o)
-	);
-
-	wire _ADBint;
-	wire ADBST0 = ~via_pb_oe[4] | via_pb_o[4];
-	wire ADBST1 = ~via_pb_oe[5] | via_pb_o[5];
-	wire ADBListen;
-
-	reg kbdclk;
-	reg [10:0] kbdclk_count;
-	reg kbd_transmitting, kbd_wait_receiving, kbd_receiving;
-	reg [2:0] kbd_bitcnt;
-
-	wire cb2_i = kbddata_o;
-	wire cb2_o, cb2_t;
-	wire kbddat_i = ~cb2_t | cb2_o;
-	reg kbddata_o;
-	reg  [7:0] kbd_to_mac;
-	reg kbd_data_valid;
-
-	// Keyboard transmitter-receiver
-	always @(posedge clk32) begin
-		if (clk8_en_p) begin
-			if ((kbd_transmitting && !kbd_wait_receiving) || kbd_receiving) begin
-				kbdclk_count <= kbdclk_count + 1'd1;
-				if (kbdclk_count == (machineType ? 8'd80 : 12'd1300)) begin // ~165usec - Mac Plus / faster - ADB
-					kbdclk <= ~kbdclk;
-					kbdclk_count <= 0;
-					if (kbdclk) begin 
-						// shift before the falling edge
-						if (kbd_transmitting) kbd_out_data <= { kbd_out_data[6:0], kbddat_i };
-						if (kbd_receiving) kbddata_o <= kbd_to_mac[7-kbd_bitcnt];
-					end
-				end
-			end else begin
-				kbdclk_count <= 0;
-				kbdclk <= 1;
-			end
-		end
-	end
-
-	// Keyboard control
-	always @(posedge clk32) begin
-		reg kbdclk_d;
-		reg ADBListenD;
-		if (!_cpuReset) begin
-			kbd_bitcnt <= 0;
-			kbd_transmitting <= 0;
-			kbd_wait_receiving <= 0;
-			kbd_data_valid <= 0;
-			ADBListenD <= 0;
-		end else if (clk8_en_p) begin
-			if (kbd_in_strobe && !machineType) begin
-				kbd_to_mac <= kbd_in_data;
-				kbd_data_valid <= 1;
-			end
-
-			if (adb_dout_strobe && machineType) begin
-				kbd_to_mac <= adb_dout;
-				kbd_receiving <= 1;
-			end
-
-			kbd_out_strobe <= 0;
-			adb_din_strobe <= 0;
-			kbdclk_d <= kbdclk;
-
-			// Only the Macintosh can initiate communication over the keyboard lines. On
-			// power-up of either the Macintosh or the keyboard, the Macintosh is in
-			// charge, and the external device is passive. The Macintosh signals that it's
-			// ready to begin communication by pulling the keyboard data line low.
-			if (!machineType && !kbd_transmitting && !kbd_receiving && !kbddat_i) begin
-				kbd_transmitting <= 1;
-				kbd_bitcnt <= 0;
-			end
-
-			// ADB transmission start
-			if (machineType && !kbd_transmitting && !kbd_receiving) begin
-				ADBListenD <= ADBListen;
-				if (!ADBListenD && ADBListen) begin
-					kbd_transmitting <= 1;
-					kbd_bitcnt <= 0;
-				end
-			end
-
-			// The last bit of the command leaves the keyboard data line low; the
-			// Macintosh then indicates it's ready to receive the keyboard's response by
-			// setting the data line high. 
-			if (kbd_wait_receiving && kbddat_i && kbd_data_valid) begin
-				kbd_wait_receiving <= 0;
-				kbd_receiving <= 1;
-				kbd_transmitting <= 0;
-			end
-
-			// send/receive bits at rising edge of the keyboard clock
-			if (~kbdclk_d & kbdclk) begin
-				kbd_bitcnt <= kbd_bitcnt + 1'd1;
-
-				if (kbd_bitcnt == 3'd7) begin
-					if (kbd_transmitting) begin
-						if (!machineType) begin
-							kbd_out_strobe <= 1;
-							kbd_wait_receiving <= 1;
-						end else begin
-							adb_din_strobe <= 1;
-							adb_din <= kbd_out_data;
-							kbd_transmitting <= 0;
-						end
-					end
-					if (kbd_receiving) begin
-						kbd_receiving <= 0;
-						kbd_data_valid <= 0;
-					end
-				end
-			end
-		end
-	end
-
-	// IWM
-	iwm i(
-		.clk(clk32),
-		.cep(clk8_en_p),
-		.cen(clk8_en_n),
-		._reset(_cpuReset),
-		.selectIWM(selectIWM),
-		._cpuRW(_cpuRW),
-		._cpuLDS(_cpuLDS),
-		.dataIn(cpuDataIn),
-		.cpuAddrRegHi(cpuAddrRegHi),
-		.SEL(SEL),
-		.driveSel(driveSel),
-		.dataOut(iwmDataOut),
-		.insertDisk(insertDisk),
-		.diskSides(diskSides),
-		.diskEject(diskEject),
-		.diskMotor(diskMotor),
-		.diskAct(diskAct),
-
-		.dskReadAddrInt(dskReadAddrInt),
-		.dskReadAckInt(dskReadAckInt),
-		.dskReadAddrExt(dskReadAddrExt),
-		.dskReadAckExt(dskReadAckExt),
-		.dskReadData(memoryDataIn[7:0])
-	);
-
-	// SCC
-	scc s(
-		.clk(clk32),
+module dataController_top(
+	// clocks:
+	input clk32,					// 32.5 MHz pixel clock
+	input clk8_en_p,
+	input clk8_en_n,
+	input E_rising,
+	input E_falling,
+
+	// system control:
+	input machineType, // 0 - Mac Plus, 1 - Mac SE
+	input _systemReset,
+
+	// 68000 CPU control:
+	output _cpuReset,
+	output [2:0] _cpuIPL,
+
+	// 68000 CPU memory interface:
+	input [15:0] cpuDataIn,
+	input [3:0] cpuAddrRegHi, // A12-A9
+	input [2:0] cpuAddrRegMid, // A6-A4
+	input [1:0] cpuAddrRegLo, // A2-A1
+	input _cpuUDS,
+	input _cpuLDS,
+	input _cpuRW,
+	output [15:0] cpuDataOut,
+
+	// peripherals:
+	input selectSCSI,
+	input selectSCC,
+	input selectIWM,
+	input selectVIA,
+	input selectSEOverlay,
+	input selectNuBus,
+	input [15:0] nubusDataIn,
+	input nubus_irq_n,
+	input _cpuVMA,
+
+	// RAM/ROM:
+	input videoBusControl,
+	input cpuBusControl,
+	input [15:0] memoryDataIn,
+	output [15:0] memoryDataOut,
+	input memoryLatch,
+
+	// keyboard:
+	input [10:0] ps2_key,
+	output capslock,
+
+	// mouse:
+	input [24:0] ps2_mouse,
+
+	// serial:
+	input serialIn,
+	output serialOut,
+	input serialCTS,
+	output serialRTS,
+
+	// RTC
+	input [32:0] timestamp,
+
+	// video:
+	output pixelOut,
+	input _hblank,
+	input _vblank,
+	input loadPixels,
+	output vid_alt,
+
+	// audio
+	output [10:0] audioOut,  // 8 bit audio + 3 bit volume
+	output snd_alt,
+	input loadSound,
+
+	// misc
+	output memoryOverlayOn,
+	input [1:0] insertDisk,
+	input [1:0] diskSides,
+	output [1:0] diskEject,
+	output [1:0] diskMotor,
+	output [1:0] diskAct,
+
+	output [21:0] dskReadAddrInt,
+	input dskReadAckInt,
+	output [21:0] dskReadAddrExt,
+	input dskReadAckExt,
+
+	// connections to io controller
+	input   [SCSI_DEVS-1:0] img_mounted,
+	input            [31:0] img_size,
+	output           [31:0] io_lba[SCSI_DEVS],
+	output  [SCSI_DEVS-1:0] io_rd,
+	output  [SCSI_DEVS-1:0] io_wr,
+	input   [SCSI_DEVS-1:0] io_ack,
+	input             [7:0] sd_buff_addr,
+	input            [15:0] sd_buff_dout,
+	output           [15:0] sd_buff_din[SCSI_DEVS],
+	input                   sd_buff_wr
+);
+
+	parameter SCSI_DEVS = 2;
+
+	// add binary volume levels according to volume setting
+	assign audioOut =
+		(snd_vol[0]?audio_x1:11'd0) +
+		(snd_vol[1]?audio_x2:11'd0) +
+		(snd_vol[2]?audio_x4:11'd0);
+
+	// three binary volume levels *1, *2 and *4, sign expanded
+	wire [10:0] audio_x1 = { {3{audio_latch[7]}}, audio_latch };
+	wire [10:0] audio_x2 = { {2{audio_latch[7]}}, audio_latch, 1'b0 };
+	wire [10:0] audio_x4 = {    audio_latch[7]  , audio_latch, 2'b00};
+
+	reg loadSoundD;
+	always @(posedge clk32)
+		if (clk8_en_n) loadSoundD <= loadSound;
+
+	// read audio data and convert to signed for further volume adjustment
+	reg [7:0] audio_latch;
+	always @(posedge clk32) begin
+		if(clk8_en_p && loadSoundD) begin
+			if(snd_ena) audio_latch <= 8'h7f; // when disabled, drive output high
+			else  	 	audio_latch <= memoryDataIn[15:8] - 8'd128;
+		end
+	end
+
+	// CPU reset generation
+	// For initial CPU reset, RESET and HALT must be asserted for at least 100ms = 800,000 clocks of clk8
+	reg [19:0] resetDelay; // 20 bits = 1 million
+	wire isResetting = resetDelay != 0;
+
+	initial begin
+		// force a reset when the FPGA configuration is completed
+		resetDelay <= 20'hFFFFF;
+	end
+
+	always @(posedge clk32 or negedge _systemReset) begin
+		if (_systemReset == 1'b0) begin
+			resetDelay <= 20'hFFFFF;
+		end
+		else if (clk8_en_p && isResetting) begin
+			resetDelay <= resetDelay - 1'b1;
+		end
+	end
+	assign _cpuReset = isResetting ? 1'b0 : 1'b1;
+
+	// interconnects
+	wire SEL;
+	wire _viaIrq, _sccIrq, sccWReq;
+	wire [15:0] viaDataOut;
+	wire [15:0] iwmDataOut;
+	wire [7:0] sccDataOut;
+	wire [7:0] scsiDataOut;
+	wire mouseX1, mouseX2, mouseY1, mouseY2, mouseButton;
+
+	// interrupt control
+	assign _cpuIPL =
+		!_viaIrq?3'b110:
+		(!_sccIrq || !nubus_irq_n)?3'b101:
+		3'b111;
+
+
+	reg [15:0] cpu_data;
+	always @(posedge clk32) if (cpuBusControl && memoryLatch) cpu_data <= memoryDataIn;
+
+	// CPU-side data output mux
+	assign cpuDataOut = selectIWM ? iwmDataOut :
+							  selectVIA ? viaDataOut :
+							  selectNuBus ? nubusDataIn :
+							  selectSCC ? { sccDataOut, 8'hEF } :
+							  selectSCSI ? { scsiDataOut, 8'hEF } :
+							  (cpuBusControl && memoryLatch) ? memoryDataIn : cpu_data;
+
+	// Memory-side
+	assign memoryDataOut = cpuDataIn;
+
+	// SCSI
+	ncr5380 #(SCSI_DEVS) scsi(
+		.clk(clk32),
+		.reset(!_cpuReset),
+		.bus_cs(selectSCSI),
+		.bus_rs(cpuAddrRegMid),
+		.ior(!_cpuUDS),
+		.iow(!_cpuLDS),
+		.dack(cpuAddrRegHi[0]),   // A9
+		.wdata(cpuDataIn[15:8]),
+		.rdata(scsiDataOut),
+
+		// connections to io controller
+		.img_mounted( img_mounted ),
+		.img_size( img_size ),
+		.io_lba ( io_lba ),
+		.io_rd ( io_rd ),
+		.io_wr ( io_wr ),
+		.io_ack ( io_ack ),
+
+		.sd_buff_addr(sd_buff_addr),
+		.sd_buff_dout(sd_buff_dout),
+		.sd_buff_din(sd_buff_din),
+		.sd_buff_wr(sd_buff_wr)
+	);
+
+	// count vblanks, and set 1 second interrupt after 60 vblanks
+	reg [5:0] vblankCount;
+	reg _lastVblank;
+	always @(posedge clk32) begin
+		if (clk8_en_n) begin
+			_lastVblank <= _vblank;
+			if (_vblank == 1'b0 && _lastVblank == 1'b1) begin
+				if (vblankCount != 59) begin
+					vblankCount <= vblankCount + 1'b1;
+				end
+				else begin
+					vblankCount <= 6'h0;
+				end
+			end
+		end
+	end
+	wire onesec = vblankCount == 59;
+
+	// Mac SE ROM overlay switch
+	reg  SEOverlay;
+	always @(posedge clk32) begin
+		if (!_cpuReset)
+			SEOverlay <= 1;
+		else if (selectSEOverlay)
+			SEOverlay <= 0;
+	end
+
+	// VIA
+	wire [2:0] snd_vol;
+	wire snd_ena;
+	wire driveSel; // internal drive select, 0 - upper, 1 - lower
+
+	wire [7:0] via_pa_i, via_pa_o, via_pa_oe;
+	wire [7:0] via_pb_i, via_pb_o, via_pb_oe;
+	wire viaIrq;
+
+	assign _viaIrq = ~viaIrq;
+
+	//port A
+	assign via_pa_i = {sccWReq, ~via_pa_oe[6:0] | via_pa_o[6:0]};
+	assign snd_vol = ~via_pa_oe[2:0] | via_pa_o[2:0];
+	assign snd_alt = machineType ? 1'b0 : ~(~via_pa_oe[3] | via_pa_o[3]);
+	assign driveSel = machineType ? ~via_pa_oe[4] | via_pa_o[4] : 1'b1;
+	assign memoryOverlayOn = machineType ? SEOverlay : ~via_pa_oe[4] | via_pa_o[4];
+	assign SEL = ~via_pa_oe[5] | via_pa_o[5];
+	assign vid_alt = ~via_pa_oe[6] | via_pa_o[6];
+
+	//port B
+	assign via_pb_i = {1'b1, {3{machineType}} | {_hblank, mouseY2, mouseX2}, machineType ? _ADBint : mouseButton, 2'b11, rtcdat_o};
+	assign snd_ena = ~via_pb_oe[7] | via_pb_o[7];
+
+	assign viaDataOut[7:0] = 8'hEF;
+
+	via6522 via(
+		.clock      (clk32),
+		.rising     (E_rising),
+		.falling    (E_falling),
+		.reset      (!_cpuReset),
+
+		.addr       (cpuAddrRegHi),
+		.wen        (selectVIA && !_cpuVMA && !_cpuRW),
+		.ren        (selectVIA && !_cpuVMA &&  _cpuRW),
+		.data_in    (cpuDataIn[15:8]),
+		.data_out   (viaDataOut[15:8]),
+
+		.phi2_ref   (),
+
+		//-- pio --
+		.port_a_o   (via_pa_o),
+		.port_a_t   (via_pa_oe),
+		.port_a_i   (via_pa_i),
+
+		.port_b_o   (via_pb_o),
+		.port_b_t   (via_pb_oe),
+		.port_b_i   (via_pb_i),
+
+		//-- handshake pins
+		.ca1_i      (_vblank),
+		.ca2_i      (onesec),
+
+		.cb1_i      (kbdclk),
+		.cb2_i      (cb2_i),
+		.cb2_o      (cb2_o),
+		.cb2_t      (cb2_t),
+
+		.irq        (viaIrq)
+	);
+
+	wire _rtccs   = ~via_pb_oe[2] | via_pb_o[2];
+	wire rtcck    = ~via_pb_oe[1] | via_pb_o[1];
+	wire rtcdat_i = ~via_pb_oe[0] | via_pb_o[0];
+	wire rtcdat_o;
+
+	rtc pram (
+		.clk        (clk32),
+		.reset      (!_cpuReset),
+		.timestamp  (timestamp),
+		._cs        (_rtccs),
+		.ck         (rtcck),
+		.dat_i      (rtcdat_i),
+		.dat_o      (rtcdat_o)
+	);
+
+	wire _ADBint;
+	wire ADBST0 = ~via_pb_oe[4] | via_pb_o[4];
+	wire ADBST1 = ~via_pb_oe[5] | via_pb_o[5];
+	wire ADBListen;
+
+	reg kbdclk;
+	reg [10:0] kbdclk_count;
+	reg kbd_transmitting, kbd_wait_receiving, kbd_receiving;
+	reg [2:0] kbd_bitcnt;
+
+	wire cb2_i = kbddata_o;
+	wire cb2_o, cb2_t;
+	wire kbddat_i = ~cb2_t | cb2_o;
+	reg kbddata_o;
+	reg  [7:0] kbd_to_mac;
+	reg kbd_data_valid;
+
+	// Keyboard transmitter-receiver
+	always @(posedge clk32) begin
+		if (clk8_en_p) begin
+			if ((kbd_transmitting && !kbd_wait_receiving) || kbd_receiving) begin
+				kbdclk_count <= kbdclk_count + 1'd1;
+				if (kbdclk_count == (machineType ? 8'd80 : 12'd1300)) begin // ~165usec - Mac Plus / faster - ADB
+					kbdclk <= ~kbdclk;
+					kbdclk_count <= 0;
+					if (kbdclk) begin
+						// shift before the falling edge
+						if (kbd_transmitting) kbd_out_data <= { kbd_out_data[6:0], kbddat_i };
+						if (kbd_receiving) kbddata_o <= kbd_to_mac[7-kbd_bitcnt];
+					end
+				end
+			end else begin
+				kbdclk_count <= 0;
+				kbdclk <= 1;
+			end
+		end
+	end
+
+	// Keyboard control
+	always @(posedge clk32) begin
+		reg kbdclk_d;
+		reg ADBListenD;
+		if (!_cpuReset) begin
+			kbd_bitcnt <= 0;
+			kbd_transmitting <= 0;
+			kbd_wait_receiving <= 0;
+			kbd_data_valid <= 0;
+			ADBListenD <= 0;
+		end else if (clk8_en_p) begin
+			if (kbd_in_strobe && !machineType) begin
+				kbd_to_mac <= kbd_in_data;
+				kbd_data_valid <= 1;
+			end
+
+			if (adb_dout_strobe && machineType) begin
+				kbd_to_mac <= adb_dout;
+				kbd_receiving <= 1;
+			end
+
+			kbd_out_strobe <= 0;
+			adb_din_strobe <= 0;
+			kbdclk_d <= kbdclk;
+
+			// Only the Macintosh can initiate communication over the keyboard lines. On
+			// power-up of either the Macintosh or the keyboard, the Macintosh is in
+			// charge, and the external device is passive. The Macintosh signals that it's
+			// ready to begin communication by pulling the keyboard data line low.
+			if (!machineType && !kbd_transmitting && !kbd_receiving && !kbddat_i) begin
+				kbd_transmitting <= 1;
+				kbd_bitcnt <= 0;
+			end
+
+			// ADB transmission start
+			if (machineType && !kbd_transmitting && !kbd_receiving) begin
+				ADBListenD <= ADBListen;
+				if (!ADBListenD && ADBListen) begin
+					kbd_transmitting <= 1;
+					kbd_bitcnt <= 0;
+				end
+			end
+
+			// The last bit of the command leaves the keyboard data line low; the
+			// Macintosh then indicates it's ready to receive the keyboard's response by
+			// setting the data line high.
+			if (kbd_wait_receiving && kbddat_i && kbd_data_valid) begin
+				kbd_wait_receiving <= 0;
+				kbd_receiving <= 1;
+				kbd_transmitting <= 0;
+			end
+
+			// send/receive bits at rising edge of the keyboard clock
+			if (~kbdclk_d & kbdclk) begin
+				kbd_bitcnt <= kbd_bitcnt + 1'd1;
+
+				if (kbd_bitcnt == 3'd7) begin
+					if (kbd_transmitting) begin
+						if (!machineType) begin
+							kbd_out_strobe <= 1;
+							kbd_wait_receiving <= 1;
+						end else begin
+							adb_din_strobe <= 1;
+							adb_din <= kbd_out_data;
+							kbd_transmitting <= 0;
+						end
+					end
+					if (kbd_receiving) begin
+						kbd_receiving <= 0;
+						kbd_data_valid <= 0;
+					end
+				end
+			end
+		end
+	end
+
+	// IWM
+	iwm i(
+		.clk(clk32),
+		.cep(clk8_en_p),
+		.cen(clk8_en_n),
+		._reset(_cpuReset),
+		.selectIWM(selectIWM),
+		._cpuRW(_cpuRW),
+		._cpuLDS(_cpuLDS),
+		.dataIn(cpuDataIn),
+		.cpuAddrRegHi(cpuAddrRegHi),
+		.SEL(SEL),
+		.driveSel(driveSel),
+		.dataOut(iwmDataOut),
+		.insertDisk(insertDisk),
+		.diskSides(diskSides),
+		.diskEject(diskEject),
+		.diskMotor(diskMotor),
+		.diskAct(diskAct),
+
+		.dskReadAddrInt(dskReadAddrInt),
+		.dskReadAckInt(dskReadAckInt),
+		.dskReadAddrExt(dskReadAddrExt),
+		.dskReadAckExt(dskReadAckExt),
+		.dskReadData(memoryDataIn[7:0])
+	);
+
+	// SCC
+	scc s(
+		.clk(clk32),
 		.cep(clk8_en_p),
-		.cen(clk8_en_n),
+		.cen(clk8_en_n),
 		.reset_hw(~_cpuReset),
-		.cs(selectSCC && (_cpuLDS == 1'b0 || _cpuUDS == 1'b0)),
+		.cs(selectSCC && (_cpuLDS == 1'b0 || _cpuUDS == 1'b0)),
 //		.cs(selectSCC && (_cpuLDS == 1'b0 || _cpuUDS == 1'b0) && cpuBusControl),
 //		.we(!_cpuRW),
-		.we(!_cpuLDS),
+		.we(!_cpuLDS),
 		.rs(cpuAddrRegLo), 
 		.wdata(cpuDataIn[15:8]),
 		.rdata(sccDataOut),
 		._irq(_sccIrq),
 		.dcd_a(mouseX1),
-		.dcd_b(mouseY1),
-		.wreq(sccWReq),
-		.txd(serialOut),
-		.rxd(serialIn),
-		.cts(serialCTS),
-		.rts(serialRTS)
-		);
-				
-	// Video
-	videoShifter vs(
-		.clk32(clk32), 
-		.memoryLatch(memoryLatch),
-		.dataIn(memoryDataIn),
-		.loadPixels(loadPixels), 
-		.pixelOut(pixelOut));
-	
-	// Mouse
-	ps2_mouse mouse(
-		.clk(clk32),
+		.dcd_b(mouseY1),
+		.wreq(sccWReq),
+		.txd(serialOut),
+		.rxd(serialIn),
+		.cts(serialCTS),
+		.rts(serialRTS)
+		);
+
+	// Video
+	videoShifter vs(
+		.clk32(clk32),
+		.memoryLatch(memoryLatch),
+		.dataIn(memoryDataIn),
+		.loadPixels(loadPixels),
+		.pixelOut(pixelOut));
+
+	// Mouse
+	ps2_mouse mouse(
+		.clk(clk32),
 		.ce(clk8_en_p),
 		.reset(~_cpuReset),
-		.ps2_mouse(ps2_mouse),
+		.ps2_mouse(ps2_mouse),
 		.x1(mouseX1),
 		.y1(mouseY1),
 		.x2(mouseX2),
 		.y2(mouseY2),
 		.button(mouseButton));
-
-	wire [7:0] kbd_in_data;
-	wire kbd_in_strobe;
-	reg  [7:0] kbd_out_data;
-	reg  kbd_out_strobe;
-
-	// Keyboard
-	ps2_kbd kbd(
-		.clk(clk32),
-		.ce(clk8_en_p),
-		.reset(~_cpuReset),
-		.ps2_key(ps2_key),
-		.data_out(kbd_out_data),              // data from mac
-		.strobe_out(kbd_out_strobe),
-		.data_in(kbd_in_data),         // data to mac
-		.strobe_in(kbd_in_strobe),
-		.capslock(capslock)
-		);
-		
-	reg  [7:0] adb_din;
-	reg        adb_din_strobe;
-	wire [7:0] adb_dout;
-	wire       adb_dout_strobe;
-
-	adb adb(
-		.clk(clk32),
-		.clk_en(clk8_en_p),
-		.reset(~_cpuReset),
-		.st({ADBST1, ADBST0}),
-		._int(_ADBint),
-		.viaBusy(kbd_transmitting || kbd_receiving),
-		.listen(ADBListen),
-		.adb_din(adb_din),
-		.adb_din_strobe(adb_din_strobe),
-		.adb_dout(adb_dout),
-		.adb_dout_strobe(adb_dout_strobe),
-
-		.ps2_mouse(ps2_mouse),
-		.ps2_key(ps2_key)
-	);
-
-endmodule
+
+	wire [7:0] kbd_in_data;
+	wire kbd_in_strobe;
+	reg  [7:0] kbd_out_data;
+	reg  kbd_out_strobe;
+
+	// Keyboard
+	ps2_kbd kbd(
+		.clk(clk32),
+		.ce(clk8_en_p),
+		.reset(~_cpuReset),
+		.ps2_key(ps2_key),
+		.data_out(kbd_out_data),              // data from mac
+		.strobe_out(kbd_out_strobe),
+		.data_in(kbd_in_data),         // data to mac
+		.strobe_in(kbd_in_strobe),
+		.capslock(capslock)
+		);
+
+	reg  [7:0] adb_din;
+	reg        adb_din_strobe;
+	wire [7:0] adb_dout;
+	wire       adb_dout_strobe;
+
+	adb adb(
+		.clk(clk32),
+		.clk_en(clk8_en_p),
+		.reset(~_cpuReset),
+		.st({ADBST1, ADBST0}),
+		._int(_ADBint),
+		.viaBusy(kbd_transmitting || kbd_receiving),
+		.listen(ADBListen),
+		.adb_din(adb_din),
+		.adb_din_strobe(adb_din_strobe),
+		.adb_dout(adb_dout),
+		.adb_dout_strobe(adb_dout_strobe),
+
+		.ps2_mouse(ps2_mouse),
+		.ps2_key(ps2_key)
+	);
+
+endmodule
diff --git a/rtl/nubus/nubus_video.sv b/rtl/nubus/nubus_video.sv
new file mode 100644
index 0000000..38e60b4
--- /dev/null
+++ b/rtl/nubus/nubus_video.sv
@@ -0,0 +1,310 @@
+module nubus_video (
+    input clk,
+    input reset,
+
+    // CPU Interface (NuBus Slot)
+    input [31:0] addr,
+    input [15:0] data_in,
+    output reg [15:0] data_out,
+    // uds_lds are Active High here (inverted from _cpuUDS/_cpuLDS in top level)
+    input [1:0] uds_lds, // {uds, lds} - 1=active
+    input rw_n, // 1=read, 0=write
+    input select, // Chip select
+    output reg ack_n, // DTACK (Active Low)
+    output reg nmrq_n, // Interrupt Request (Active Low)
+
+    // Video Output
+    output [7:0] vga_r,
+    output [7:0] vga_g,
+    output [7:0] vga_b,
+    output vga_hs,
+    output vga_vs,
+    output vga_blank,
+    output vga_clk,
+
+    // IOCTL Interface for ROM Download
+    // Assumes WIDE(1) in hps_io (16-bit data)
+    input        ioctl_wr,
+    input [24:0] ioctl_addr,
+    input [15:0] ioctl_data, // 16-bit data from HPS
+    input        ioctl_download,
+    input [7:0]  ioctl_index // Expecting Index 4 for Video ROM
+);
+
+    // Video Parameters (Standard 640x480 @ 66.67Hz)
+    parameter H_RES = 640;
+    parameter V_RES = 480;
+
+    parameter H_TOTAL = 864;
+    parameter H_SYNC_START = 640 + 64;
+    parameter H_SYNC_END = 640 + 64 + 64;
+    parameter V_TOTAL = 525;
+    parameter V_SYNC_START = 480 + 3;
+    parameter V_SYNC_END = 480 + 3 + 3;
+
+    // VRAM (300KB - Exact 640x480)
+    // 16-bit width to allow Byte Enable inference
+    // 307200 bytes = 153600 words
+    (* ramstyle = "no_rw_check, M10K" *) reg [15:0] vram [0:153599];
+
+    // CLUT (Color Look-Up Table) - 256 entries x 24 bits
+    reg [23:0] clut [0:255];
+
+    // ROM Buffer (32KB)
+    reg [7:0] rom [0:32767];
+
+    // Registers
+    reg [7:0] reg_control;       // 0x080000
+    reg [7:0] reg_pixel_mask;    // 0x080018
+    reg [7:0] reg_clut_addr_wr;  // 0x080010
+    reg [7:0] reg_clut_addr_rd;  // 0x08001C
+    reg [1:0] clut_seq_cnt;      // 0=Red, 1=Green, 2=Blue
+    reg [23:0] clut_temp_data;   // Temp storage for RGB
+
+    // Interrupt State
+    reg irq_active;
+    reg irq_clear;
+
+    // Bit Depth decoding from Control Register
+    // Using bits 5:4 as standard Toby/RBV mode bits
+    // 00=1bpp, 01=2bpp, 10=4bpp, 11=8bpp
+    wire [1:0] mode = reg_control[5:4];
+    wire video_en = reg_control[7];
+    wire irq_en = reg_control[0];
+
+    // Video Counters
+    reg [10:0] h_cnt;
+    reg [10:0] v_cnt;
+
+    // Pipelined Syncs to match BRAM latency (1 cycle)
+    reg vga_hs_reg, vga_vs_reg, vga_blank_reg;
+
+    always @(posedge clk) begin
+        if (reset) begin
+            vga_hs_reg <= 1;
+            vga_vs_reg <= 1;
+            vga_blank_reg <= 1;
+        end else begin
+            vga_hs_reg <= ~(h_cnt >= H_SYNC_START && h_cnt < H_SYNC_END);
+            vga_vs_reg <= ~(v_cnt >= V_SYNC_START && v_cnt < V_SYNC_END);
+            vga_blank_reg <= (h_cnt >= H_RES) || (v_cnt >= V_RES) || !video_en;
+        end
+    end
+
+    assign vga_hs = vga_hs_reg;
+    assign vga_vs = vga_vs_reg;
+    assign vga_blank = vga_blank_reg;
+    assign vga_clk = clk;
+
+    // Interrupt Generation (VBL)
+    reg vbl_pulse;
+    always @(posedge clk) begin
+        if (reset) begin
+            h_cnt <= 11'd0;
+            v_cnt <= 11'd0;
+            vbl_pulse <= 0;
+        end else begin
+            vbl_pulse <= 0;
+            if (h_cnt == H_TOTAL - 1) begin
+                h_cnt <= 11'd0;
+                if (v_cnt == V_TOTAL - 1) begin
+                    v_cnt <= 11'd0;
+                end else begin
+                    v_cnt <= v_cnt + 11'd1;
+                    if (v_cnt == V_RES - 1) // Next is V_RES (Start of VBlank)
+                        vbl_pulse <= 1;
+                end
+            end else begin
+                h_cnt <= h_cnt + 11'd1;
+            end
+        end
+    end
+
+    // Interrupt Logic
+    always @(posedge clk) begin
+        if (reset) begin
+            irq_active <= 0;
+            nmrq_n <= 1;
+        end else begin
+            if (vbl_pulse && irq_en)
+                irq_active <= 1;
+
+            if (irq_clear)
+                irq_active <= 0;
+
+            nmrq_n <= ~irq_active;
+        end
+    end
+
+    // Video Output Logic
+    reg [17:0] fetch_addr;
+    reg byte_sel;
+
+    always @(*) begin
+        case (mode)
+            2'b00: begin // 1bpp
+                // (v * 40) + (h >> 4)
+                fetch_addr = (v_cnt * 18'd40) + (h_cnt >> 4);
+                byte_sel = (h_cnt[3] == 0) ? 1'b0 : 1'b1;
+            end
+            2'b01: begin // 2bpp
+                // (v * 80) + (h >> 3)
+                fetch_addr = (v_cnt * 18'd80) + (h_cnt >> 3);
+                byte_sel = (h_cnt[2] == 0) ? 1'b0 : 1'b1;
+            end
+            2'b10: begin // 4bpp
+                // (v * 160) + (h >> 2)
+                fetch_addr = (v_cnt * 18'd160) + (h_cnt >> 2);
+                byte_sel = (h_cnt[1] == 0) ? 1'b0 : 1'b1;
+            end
+            2'b11: begin // 8bpp
+                // (v * 320) + (h >> 1)
+                fetch_addr = (v_cnt * 18'd320) + (h_cnt >> 1);
+                byte_sel = (h_cnt[0] == 0) ? 1'b0 : 1'b1;
+            end
+        endcase
+    end
+
+    // Fetch VRAM (Word)
+    reg [15:0] vram_word;
+    always @(posedge clk) begin
+        vram_word <= vram[fetch_addr];
+    end
+
+    // Delayed byte select
+    reg byte_sel_d;
+    always @(posedge clk) begin
+        byte_sel_d <= byte_sel;
+    end
+
+    // Select Byte
+    wire [7:0] vram_byte = (byte_sel_d == 0) ? vram_word[15:8] : vram_word[7:0];
+
+    // Pipelined h_cnt for pixel extraction
+    reg [2:0] h_cnt_d;
+    always @(posedge clk) begin
+        h_cnt_d <= h_cnt[2:0];
+    end
+
+    reg [7:0] pixel_idx;
+    // Extract Pixel Index
+    always @(*) begin
+        case (mode)
+            2'b00: // 1bpp
+                pixel_idx = 8'({7'b0, vram_byte[~h_cnt_d]});
+
+            2'b01: // 2bpp
+                case (h_cnt_d[1:0])
+                    2'b00: pixel_idx = 8'({6'b0, vram_byte[7:6]});
+                    2'b01: pixel_idx = 8'({6'b0, vram_byte[5:4]});
+                    2'b10: pixel_idx = 8'({6'b0, vram_byte[3:2]});
+                    2'b11: pixel_idx = 8'({6'b0, vram_byte[1:0]});
+                endcase
+
+            2'b10: // 4bpp
+                case (h_cnt_d[0])
+                    1'b0: pixel_idx = 8'({4'b0, vram_byte[7:4]});
+                    1'b1: pixel_idx = 8'({4'b0, vram_byte[3:0]});
+                endcase
+
+            2'b11: // 8bpp
+                pixel_idx = vram_byte;
+        endcase
+    end
+
+    // Apply Pixel Mask and Lookup CLUT
+    wire [7:0] masked_idx = pixel_idx & reg_pixel_mask;
+
+    assign vga_r = vga_blank ? 8'h00 : clut[masked_idx][23:16];
+    assign vga_g = vga_blank ? 8'h00 : clut[masked_idx][15:8];
+    assign vga_b = vga_blank ? 8'h00 : clut[masked_idx][7:0];
+
+    // ROM Download
+    always @(posedge clk) begin
+        if (ioctl_wr && ioctl_download && (ioctl_index == 8'd4)) begin
+            if (ioctl_addr < 16384) begin
+                rom[{ioctl_addr[13:0], 1'b0}] <= ioctl_data[7:0];
+                rom[{ioctl_addr[13:0], 1'b1}] <= ioctl_data[15:8];
+            end
+        end
+    end
+
+    // NuBus Interface
+    wire [17:0] vram_word_addr = addr[18:1];
+
+    always @(posedge clk) begin
+        irq_clear <= 0;
+
+        if (reset) begin
+            ack_n <= 1;
+            reg_control <= 0;
+            reg_pixel_mask <= 8'hFF;
+            reg_clut_addr_wr <= 0;
+            reg_clut_addr_rd <= 0;
+            clut_seq_cnt <= 0;
+        end else if (select) begin
+            if (ack_n) begin
+                ack_n <= 0; // Assert ACK
+
+                if (!rw_n) begin // Write
+                    // VRAM
+                    if (addr[23:19] == 5'b00000) begin
+                        if (vram_word_addr < 153600) begin
+                            if (uds_lds[1]) vram[vram_word_addr][15:8] <= data_in[15:8];
+                            if (uds_lds[0]) vram[vram_word_addr][7:0]  <= data_in[7:0];
+                        end
+                    end
+                    // Registers
+                    else if (addr[23:16] == 8'h08) begin
+                        case (addr[15:0])
+                            16'h0000: if (uds_lds[1]) reg_control <= data_in[15:8];
+                            16'h0004: if (uds_lds[1]) irq_clear <= 1;
+                            16'h0010: if (uds_lds[1]) begin
+                                reg_clut_addr_wr <= data_in[15:8];
+                                clut_seq_cnt <= 0;
+                            end
+                            16'h0014: if (uds_lds[1]) begin
+                                case (clut_seq_cnt)
+                                    0: begin clut_temp_data[23:16] <= data_in[15:8]; clut_seq_cnt <= 1; end
+                                    1: begin clut_temp_data[15:8]  <= data_in[15:8]; clut_seq_cnt <= 2; end
+                                    2: begin
+                                        clut[reg_clut_addr_wr] <= {clut_temp_data[23:16], clut_temp_data[15:8], data_in[15:8]};
+                                        reg_clut_addr_wr <= reg_clut_addr_wr + 1;
+                                        clut_seq_cnt <= 0;
+                                    end
+                                endcase
+                            end
+                            16'h0018: if (uds_lds[1]) reg_pixel_mask <= data_in[15:8];
+                            16'h001C: if (uds_lds[1]) reg_clut_addr_rd <= data_in[15:8];
+                        endcase
+                    end
+                end else begin // Read
+                    data_out <= 0;
+
+                    // VRAM
+                    if (addr[23:19] == 5'b00000) begin
+                         if (vram_word_addr < 153600)
+                            data_out <= vram[vram_word_addr];
+                    end
+                    // Registers
+                    else if (addr[23:16] == 8'h08) begin
+                         case (addr[15:0])
+                            16'h0008: data_out[15:8] <= 8'b00000011;
+                            16'h0018: data_out[15:8] <= reg_pixel_mask;
+                            // Readback for CLUT Read Address to suppress unused warning
+                            16'h001C: data_out[15:8] <= reg_clut_addr_rd;
+                         endcase
+                    end
+                    // ROM
+                    else if (addr[23:20] == 4'hF) begin
+                        data_out[15:8] <= rom[addr[14:0]];
+                        data_out[7:0] <= rom[addr[14:0] | 1];
+                    end
+                end
+            end
+        end else begin
+            ack_n <= 1;
+        end
+    end
+
+endmodule
